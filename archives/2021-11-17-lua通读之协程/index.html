<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>lua通读之协程 | 虚空之地</title><meta name="keywords" content="lua,程序设计"><meta name="author" content="逯晓零"><meta name="copyright" content="逯晓零"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="协程的基本用法前言协程是lua十分有趣的一部分，它并非多线程，而是单线程，用法有点goto，但有本质区别。但我们需要注意这属于脚本动态语言，静态语言没有，也没有需要这种功能的必要。 含义协程是一段代码的封装，一般通过一个“线程”将代码包装起来，其特点是可以中途挂起(yield)和恢复(resume)。不过在lua的线程与一般语言的线程不太一样。 协程状态对于一个协程有四种状态，‘running’协">
<meta property="og:type" content="article">
<meta property="og:title" content="lua通读之协程">
<meta property="og:url" content="http://example.com/archives/2021-11-17-lua%E9%80%9A%E8%AF%BB%E4%B9%8B%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="虚空之地">
<meta property="og:description" content="协程的基本用法前言协程是lua十分有趣的一部分，它并非多线程，而是单线程，用法有点goto，但有本质区别。但我们需要注意这属于脚本动态语言，静态语言没有，也没有需要这种功能的必要。 含义协程是一段代码的封装，一般通过一个“线程”将代码包装起来，其特点是可以中途挂起(yield)和恢复(resume)。不过在lua的线程与一般语言的线程不太一样。 协程状态对于一个协程有四种状态，‘running’协">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-11-17T00:33:29.000Z">
<meta property="article:modified_time" content="2023-09-03T13:50:19.112Z">
<meta property="article:author" content="逯晓零">
<meta property="article:tag" content="lua">
<meta property="article:tag" content="程序设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/archives/2021-11-17-lua%E9%80%9A%E8%AF%BB%E4%B9%8B%E5%8D%8F%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'lua通读之协程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-03 21:50:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/articles/"><i class="fa-fw fa fa-book"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/dream/"><i class="fa-fw fa fa-lightbulb"></i><span> 往逝</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">虚空之地</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/articles/"><i class="fa-fw fa fa-book"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/dream/"><i class="fa-fw fa fa-lightbulb"></i><span> 往逝</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">lua通读之协程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-17T00:33:29.000Z" title="发表于 2021-11-17 08:33:29">2021-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-03T13:50:19.112Z" title="更新于 2023-09-03 21:50:19">2023-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="协程的基本用法"><a href="#协程的基本用法" class="headerlink" title="协程的基本用法"></a>协程的基本用法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>协程是lua十分有趣的一部分，它并非多线程，而是单线程，用法有点goto，但有本质区别。但我们需要注意这属于脚本动态语言，静态语言没有，也没有需要这种功能的必要。</p>
<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>协程是一段代码的封装，一般通过一个“线程”将代码包装起来，其特点是可以中途挂起(yield)和恢复(resume)。不过在lua的线程与一般语言的线程不太一样。</p>
<h2 id="协程状态"><a href="#协程状态" class="headerlink" title="协程状态"></a>协程状态</h2><p>对于一个协程有四种状态，‘running’协程正在运行，‘suspended’协程处于挂起状态，‘normal’协程处于唤起另一个协程的状态中，‘dead’协程运行完毕。由‘normal’我们就可以知道，lua程序运行时，只能有一个协程处于‘running’状态，由‘dead’我们可以知道，一个协程只能运行一次。</p>
<h2 id="lua里的使用"><a href="#lua里的使用" class="headerlink" title="lua里的使用"></a>lua里的使用</h2><p>在lua里，协程的主要库函数有三个<code>coroutine.create(f)</code>，<code>coroutine.yield (···)</code>和<code>coroutine.resume (co [, val1, ···])</code>。</p>
<h3 id="coroutine-create"><a href="#coroutine-create" class="headerlink" title="coroutine.create"></a>coroutine.create</h3><p>用于创建一个协程，传入一个函数用于封装代码，其返回值是一个协程引用，使用<code>type</code>的输出是thread。</p>
<h3 id="coroutine-yield-…-与coroutine-resume-co-···"><a href="#coroutine-yield-…-与coroutine-resume-co-···" class="headerlink" title="coroutine.yield(…)与coroutine.resume (co , ···)"></a>coroutine.yield(…)与coroutine.resume (co , ···)</h3><p>这两个函数交替使用互相呼应，‘coroutine.resume (co , …)’用于唤起co协程，属于在一个协程里唤起另一个协程，值得注意的是我们的lua程序也是一个协程，称为主协程。…用于向协程传参，如果协程没有运行，则作为协程封装函数的参数。然后‘coroutine.yield(…)’用于挂起当前正在运行定位协程，参数用来作为唤起此协程的resume的返回值的后部分，resume的第一个返回值是bool类型，用来说明协程是否运行正常。第二次使用resume的参数则将作为yield的返回值。如果协程已经dead则直接返回false和报错信息。</p>
<h3 id="官方案例"><a href="#官方案例" class="headerlink" title="官方案例"></a>官方案例</h3><figure class="highlight c"><figcaption><span>main.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">foo</span> <span class="params">(a)</span></span><br><span class="line">  <span class="title function_">print</span><span class="params">(<span class="string">&quot;foo&quot;</span>, a)</span></span><br><span class="line">  <span class="keyword">return</span> coroutine.<span class="title function_">yield</span><span class="params">(<span class="number">2</span>*a)</span></span><br><span class="line">end</span><br><span class="line">co = coroutine.create(function (a,b)</span><br><span class="line">      print(<span class="string">&quot;co-body&quot;</span>, a, b)</span><br><span class="line">      local r = foo(a+<span class="number">1</span>)</span><br><span class="line">      print(<span class="string">&quot;co-body&quot;</span>, r)</span><br><span class="line">      local r, s = coroutine.yield(a+b, a-b)</span><br><span class="line">      print(<span class="string">&quot;co-body&quot;</span>, r, s)</span><br><span class="line">      <span class="keyword">return</span> b, <span class="string">&quot;end&quot;</span></span><br><span class="line">end)</span><br><span class="line">print(<span class="string">&quot;main&quot;</span>, coroutine.resume(co, <span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">print(<span class="string">&quot;main&quot;</span>, coroutine.resume(co, <span class="string">&quot;r&quot;</span>))</span><br><span class="line">print(<span class="string">&quot;main&quot;</span>, coroutine.resume(co, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>))</span><br><span class="line">print(<span class="string">&quot;main&quot;</span>, coroutine.resume(co, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">co-body 1       10</span><br><span class="line">foo     2</span><br><span class="line">main    <span class="literal">true</span>    4</span><br><span class="line">co-body r</span><br><span class="line">main    <span class="literal">true</span>    11      -9</span><br><span class="line">co-body x       y</span><br><span class="line">main    <span class="literal">true</span>    10      end</span><br><span class="line">main    <span class="literal">false</span>   cannot resume dead coroutine</span><br></pre></td></tr></table></figure>
<p>这一个例子已经把协程的运行过程说透了。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><code>coroutine.running()</code>返回正在运行的协程，如果是主协程则返回nil，也就是说明了主协程的特殊性。<code>coroutine.status(co)</code>返回协程co的运行状态，如之前所说的四种情况。<code>coroutine.wrap(f)</code>在<code>coroutine.create(f)</code>基础上，将协程封装为函数，调用此函数相当于调用<code>coroutine.resume</code>。协程的基本用法其实挺简单的，我们主要去分析源码。</p>
<h1 id="协程的源码解读"><a href="#协程的源码解读" class="headerlink" title="协程的源码解读"></a>协程的源码解读</h1><p>有关协程的函数我们主要分析三个，它们是在<code>lbaselib.c</code>里的<code>luaB_cocreate</code>，<code>luaB_coresume</code>和<code>luaB_yield</code>，他们分别对应了<code>coroutine.create</code>，<code>coroutine.resume</code>和<code>coroutine.yield</code>。在此之前我们先说明一下，协程在C源码里的本质数据结构其实是<code>lua_State</code>，我们之前一直把它叫做lua虚拟机的东西，其实在lua_State申明上面也写了<code>per thread&#39; state</code>，不过两者的创建是有区别的，我们分别来看看。</p>
<h2 id="lua-newstate创建主协程-lua虚拟机"><a href="#lua-newstate创建主协程-lua虚拟机" class="headerlink" title="lua_newstate创建主协程(lua虚拟机)"></a>lua_newstate创建主协程(lua虚拟机)</h2><p>我们之前虽然一直使用的是<code>lua_open</code>，但实际调用的都是此函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lua.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lua_open() luaL_newstate()</span></span><br><span class="line"><span class="comment">//lauxlib.c</span></span><br><span class="line">LUALIB_API lua_State *<span class="title function_">luaL_newstate</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  lua_State *L = lua_newstate(l_alloc, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (L) lua_atpanic(L, &amp;panic);</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>l_alloc</code>是一个用于分配内存的函数，有关内存管理是C的必修课，不多讲。<code>lua_atpanic</code>用于给虚拟机挂上一个报错函数，主要在C方面，看源码的话，就输出一句<code>*unprotected call*</code>，属于debug这个大坑。  </p>
<figure class="highlight c"><figcaption><span>lstate.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">LUA_API lua_State *<span class="title function_">lua_newstate</span> <span class="params">(lua_Alloc f, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  lua_State *L;</span><br><span class="line">  global_State *g;</span><br><span class="line">  <span class="type">void</span> *l = (*f)(ud, <span class="literal">NULL</span>, <span class="number">0</span>, state_size(LG));</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  L = tostate(l);</span><br><span class="line">  g = &amp;((LG *)L)-&gt;g;</span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  L-&gt;tt = LUA_TTHREAD;</span><br><span class="line">  g-&gt;currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);</span><br><span class="line">  L-&gt;marked = luaC_white(g);</span><br><span class="line">  set2bits(L-&gt;marked, FIXEDBIT, SFIXEDBIT);</span><br><span class="line">  preinit_state(L, g);</span><br><span class="line">  g-&gt;frealloc = f;</span><br><span class="line">  g-&gt;ud = ud;</span><br><span class="line">  g-&gt;mainthread = L;</span><br><span class="line">  g-&gt;uvhead.u.l.prev = &amp;g-&gt;uvhead;</span><br><span class="line">  g-&gt;uvhead.u.l.next = &amp;g-&gt;uvhead;</span><br><span class="line">  g-&gt;GCthreshold = <span class="number">0</span>;  <span class="comment">/* mark it as unfinished state */</span></span><br><span class="line">  g-&gt;strt.size = <span class="number">0</span>;</span><br><span class="line">  g-&gt;strt.nuse = <span class="number">0</span>;</span><br><span class="line">  g-&gt;strt.hash = <span class="literal">NULL</span>;</span><br><span class="line">  setnilvalue(registry(L));</span><br><span class="line">  luaZ_initbuffer(L, &amp;g-&gt;buff);</span><br><span class="line">  g-&gt;panic = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;gcstate = GCSpause;</span><br><span class="line">  g-&gt;rootgc = obj2gco(L);</span><br><span class="line">  g-&gt;sweepstrgc = <span class="number">0</span>;</span><br><span class="line">  g-&gt;sweepgc = &amp;g-&gt;rootgc;</span><br><span class="line">  g-&gt;gray = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;weak = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;tmudata = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;totalbytes = <span class="keyword">sizeof</span>(LG);</span><br><span class="line">  g-&gt;gcpause = LUAI_GCPAUSE;</span><br><span class="line">  g-&gt;gcstepmul = LUAI_GCMUL;</span><br><span class="line">  g-&gt;gcdept = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TAGS; i++) g-&gt;mt[i] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (luaD_rawrunprotected(L, f_luaopen, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* memory allocation error: free partial state */</span></span><br><span class="line">    close_state(L);</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    luai_userstateopen(L);</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p>虽然长，但核心就几部分，L是lua虚拟机，g是挂在L上的全局状态机，l是为L和g共同分配的内存。<code>L = tostate(l);g = &amp;((LG *)L)-&gt;g;</code>将内存分配给L和g。<code>L-&gt;tt = LUA_TTHREAD;</code>说明了我们的虚拟机是一个协程对象。<code>preinit_state</code>初始化L，包括将g挂到L上也在这里进行。<code>g-&gt;frealloc = f;</code>内存处理挂到了g上面，<code>g-&gt;mainthread = L;</code>g上还存储了我们的主协程。其它都不是很重要，不过lua放了许多空接口，比如luai_userstateopen，NUM_TAGS之类的，可见lua的野心还是挺大的，都在试图变成一个可高度扩展的语言。</p>
<h2 id="luaB-cocreate创建协程"><a href="#luaB-cocreate创建协程" class="headerlink" title="luaB_cocreate创建协程"></a>luaB_cocreate创建协程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_cocreate</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  lua_State *NL = lua_newthread(L);</span><br><span class="line">  luaL_argcheck(L, lua_isfunction(L, <span class="number">1</span>) &amp;&amp; !lua_iscfunction(L, <span class="number">1</span>), <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;Lua function expected&quot;</span>);</span><br><span class="line">  lua_pushvalue(L, <span class="number">1</span>);  <span class="comment">/* move function to top */</span></span><br><span class="line">  lua_xmove(L, NL, <span class="number">1</span>);  <span class="comment">/* move function from L to NL */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建一个协程NL，其次检查参数是否为函数，lua为了扩展还是挺辛苦的，执行<code>lua_pushvalue</code>后实际没什么变化，我们传参准确，不准确的话之前就会被测出来，再移动一遍没太多意义。记住我们之前所说，0处是我们调用函数的指针，最后将函数从L转移到NL。实际上，还有将NL放入栈顶，其实它将这放在了<code>lua_newthread</code>里，我们继续看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LUA_API lua_State *<span class="title function_">lua_newthread</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  lua_State *L1;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  luaC_checkGC(L);</span><br><span class="line">  L1 = luaE_newthread(L);</span><br><span class="line">  setthvalue(L, L-&gt;top, L1);</span><br><span class="line">  api_incr_top(L);</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  luai_userstatethread(L, L1);</span><br><span class="line">  <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>luaE_newthread</code>真正用于创建协程，<code>setthvalue(L, L-&gt;top, L1);api_incr_top(L);</code>将我们的协程入栈。我们来看看创建协程与一般的主协程有什么区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lua_State *<span class="title function_">luaE_newthread</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  lua_State *L1 = tostate(luaM_malloc(L, state_size(lua_State)));</span><br><span class="line">  luaC_link(L, obj2gco(L1), LUA_TTHREAD);</span><br><span class="line">  preinit_state(L1, G(L));</span><br><span class="line">  stack_init(L1, L);  <span class="comment">/* init stack */</span></span><br><span class="line">  setobj2n(L, gt(L1), gt(L));  <span class="comment">/* share table of globals */</span></span><br><span class="line">  L1-&gt;hookmask = L-&gt;hookmask;</span><br><span class="line">  L1-&gt;basehookcount = L-&gt;basehookcount;</span><br><span class="line">  L1-&gt;hook = L-&gt;hook;</span><br><span class="line">  resethookcount(L1);</span><br><span class="line">  lua_assert(iswhite(obj2gco(L1)));</span><br><span class="line">  <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tostate</code>直接开始分配内存了，但我们从<code>state_size(lua_State)</code>可以看到没有分配全局状态机的内存，也就是说一般协程没有全局状态机。然后它通过<code>luaC_link</code>将此协程纳入了主协程的全局状态机的垃圾回收对象里面。<code>stack_init(L1, L);</code>用来初始化我们的协程栈，L主要是用来初始化L1调用栈的，有关此我们马上也该讲讲了。<code>setobj2n</code>让L1与主协程共享全局表，也就是主协程里的全局变量和函数可以在协程里使用。<br>至此我们已经可以看出协程与主协程的区别了，如没有全局状态机，与主协程共享全局变量表等。</p>
<h2 id="CallInfo"><a href="#CallInfo" class="headerlink" title="CallInfo"></a>CallInfo</h2><p>这里我们要穿插将一下这个在lua虚拟机里俗称调用栈的东西。它的主要结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** informations about a call</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CallInfo</span> &#123;</span></span><br><span class="line">  StkId base;  <span class="comment">/* base for this function */</span></span><br><span class="line">  StkId func;  <span class="comment">/* function index in the stack */</span></span><br><span class="line">  StkId top;  <span class="comment">/* top for this function */</span></span><br><span class="line">  <span class="type">const</span> Instruction *savedpc;</span><br><span class="line">  <span class="type">int</span> nresults;  <span class="comment">/* expected number of results from this function */</span></span><br><span class="line">  <span class="type">int</span> tailcalls;  <span class="comment">/* number of tail calls lost under this entry */</span></span><br><span class="line">&#125; CallInfo;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> &#123;</span></span><br><span class="line">  ***</span><br><span class="line">  CallInfo *ci;  <span class="comment">/* call info for current function */</span></span><br><span class="line">  CallInfo *end_ci;  <span class="comment">/* points after end of ci array*/</span></span><br><span class="line">  CallInfo *base_ci;  <span class="comment">/* array of CallInfo&#x27;s */</span></span><br><span class="line">  ***</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>讲解看官方注解，我们主要看调用栈改变的时候和如何改变。其实顾名思义，改变主要源于调用<code>luaD_call</code>的<code>lua_precall()</code>函数，好久以前的坑，今天我们来看看。  </p>
<figure class="highlight c"><figcaption><span>ldo.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaD_precall</span> <span class="params">(lua_State *L, StkId func, <span class="type">int</span> nresults)</span> &#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="type">ptrdiff_t</span> funcr;</span><br><span class="line">  <span class="keyword">if</span> (!ttisfunction(func)) <span class="comment">/* `func&#x27; is not a function? */</span></span><br><span class="line">    func = tryfuncTM(L, func);  <span class="comment">/* check the `function&#x27; tag method */</span></span><br><span class="line">  funcr = savestack(L, func);</span><br><span class="line">  cl = &amp;clvalue(func)-&gt;l;</span><br><span class="line">  L-&gt;ci-&gt;savedpc = L-&gt;savedpc;</span><br><span class="line">  <span class="keyword">if</span> (!cl-&gt;isC) &#123;  <span class="comment">/* Lua function? prepare its call */</span></span><br><span class="line">    CallInfo *ci;</span><br><span class="line">    StkId st, base;</span><br><span class="line">    Proto *p = cl-&gt;p;</span><br><span class="line">    luaD_checkstack(L, p-&gt;maxstacksize);</span><br><span class="line">    func = restorestack(L, funcr);</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;is_vararg) &#123;  <span class="comment">/* no varargs? */</span></span><br><span class="line">      base = func + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (L-&gt;top &gt; base + p-&gt;numparams)</span><br><span class="line">        L-&gt;top = base + p-&gt;numparams;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* vararg function */</span></span><br><span class="line">      <span class="type">int</span> nargs = cast_int(L-&gt;top - func) - <span class="number">1</span>;</span><br><span class="line">      base = adjust_varargs(L, p, nargs);</span><br><span class="line">      func = restorestack(L, funcr);  <span class="comment">/* previous call may change the stack */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ci = inc_ci(L);  <span class="comment">/* now `enter&#x27; new function */</span></span><br><span class="line">    ci-&gt;func = func;</span><br><span class="line">    L-&gt;base = ci-&gt;base = base;</span><br><span class="line">    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;</span><br><span class="line">    lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);</span><br><span class="line">    L-&gt;savedpc = p-&gt;code;  <span class="comment">/* starting point */</span></span><br><span class="line">    ci-&gt;tailcalls = <span class="number">0</span>;</span><br><span class="line">    ci-&gt;nresults = nresults;</span><br><span class="line">    <span class="keyword">for</span> (st = L-&gt;top; st &lt; ci-&gt;top; st++)</span><br><span class="line">      setnilvalue(st);</span><br><span class="line">    L-&gt;top = ci-&gt;top;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;hookmask &amp; LUA_MASKCALL) &#123;</span><br><span class="line">      L-&gt;savedpc++;  <span class="comment">/* hooks assume &#x27;pc&#x27; is already incremented */</span></span><br><span class="line">      luaD_callhook(L, LUA_HOOKCALL, <span class="number">-1</span>);</span><br><span class="line">      L-&gt;savedpc--;  <span class="comment">/* correct &#x27;pc&#x27; */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PCRLUA;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* if is a C function, call it */</span></span><br><span class="line">    CallInfo *ci;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    luaD_checkstack(L, LUA_MINSTACK);  <span class="comment">/* ensure minimum stack size */</span></span><br><span class="line">    ci = inc_ci(L);  <span class="comment">/* now `enter&#x27; new function */</span></span><br><span class="line">    ci-&gt;func = restorestack(L, funcr);</span><br><span class="line">    L-&gt;base = ci-&gt;base = ci-&gt;func + <span class="number">1</span>;</span><br><span class="line">    ci-&gt;top = L-&gt;top + LUA_MINSTACK;</span><br><span class="line">    lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);</span><br><span class="line">    ci-&gt;nresults = nresults;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;hookmask &amp; LUA_MASKCALL)</span><br><span class="line">      luaD_callhook(L, LUA_HOOKCALL, <span class="number">-1</span>);</span><br><span class="line">    lua_unlock(L);</span><br><span class="line">    n = (*curr_func(L)-&gt;c.f)(L);  <span class="comment">/* do the actual call */</span></span><br><span class="line">    lua_lock(L);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)  <span class="comment">/* yielding? */</span></span><br><span class="line">      <span class="keyword">return</span> PCRYIELD;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      luaD_poscall(L, L-&gt;top - n);</span><br><span class="line">      <span class="keyword">return</span> PCRC;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<p>函数挺长的，我们看主要部分。cl存储函数闭包，funcr记录函数在栈上的位置。savepc是lua虚拟机当前指令的指针，<code>L-&gt;ci-&gt;savedpc = L-&gt;savedpc;</code>就是将当前CallInfo的指令存储为虚拟机当前的指令，这样记录了当前函数运行到了哪里，方便回来继续执行。接下来的if用于区别是lua闭包还是c闭包，先看上一个。首先创建一个CallInfo，也就是说每次call的时候都会产生一个CallInfo用于记录信息。st用于缓存StkId，base最后会存为lua虚拟机的base，p存储当前函数的Proto。restorestack与之前的funcr相呼应，估计是防止func的指针不小心用着给用丢了。如果没有可变参数则，base指向func+1位置，top指向base+参数个数位置，以前讲过，我们回忆一下，如果ind&gt;0返回bade+(ind-1)，如果..&lt;ind&lt;0返回top+ind，如果ind=0返回当前函数。如果有可变参数的话，先存储总参数个数，我们在调用有可变参数的函数时，对此特性是不知的，所以会将所有参数入栈，lua_call处理时也将此作为参数处理，所以要依据此函数是否有可变参数再决定是否执行<code>if (L-&gt;top &gt; base + p-&gt;numparams) L-&gt;top = base + p-&gt;numparams;</code>来清除多余的参数，<code>adjust_varargs</code>这个函数挺离谱的，它把非可变参数拷贝到栈上，返回的base就是旧top，可变参数就在base下面。我们可以看一下OP_VARAGE的执行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_VARARG: &#123;</span><br><span class="line">        <span class="type">int</span> b = GETARG_B(i) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        CallInfo *ci = L-&gt;ci;</span><br><span class="line">        <span class="type">int</span> n = cast_int(ci-&gt;base - ci-&gt;func) - cl-&gt;p-&gt;numparams - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == LUA_MULTRET) &#123;</span><br><span class="line">          Protect(luaD_checkstack(L, n));</span><br><span class="line">          ra = RA(i);  <span class="comment">/* previous call may change the stack */</span></span><br><span class="line">          b = n;</span><br><span class="line">          L-&gt;top = ra + n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">            setobjs2s(L, ra + j, ci-&gt;base - n + j);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            setnilvalue(ra + j);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>取出操作数b，注意减了一，取出当前的CallInfo，接下来就是计算可变参数个数n了，base-func是所有参数个数加一(函数不做参数)，然后减去固定参数加一，结果就是可变参数个数。如果b等于LUA_MULTRET即-1，则b=n即取出所有可变参数，接下来的for就是取出操作了。<br>我们回到原来的函数，<code>ci = inc_ci(L);</code>修改虚拟机当前的ci，ci的func指向当前函数，ci的base和L的base都为我们之前申明的新base，ci的top指向当前函数可到的最大值。<code>L-&gt;savedpc = p-&gt;code;</code>开始改变lua虚拟机指令了，原来的指令已经存到了原来的CallInfo里，然后存储返回值个数和tailcalls，这里的tailcalls是尾调用，在函数执行时才能获得值。后面不重要，最后返回PCRLUA。<br>下面是调用C闭包函数，大致差不多，而且它对可变参数熟视无睹，其实C函数本来就没这概念。<code>n = (*curr_func(L)-&gt;c.f)(L);</code>执行函数，n则是返回值的个数，这个我们以前写过，其实还可以返回一个负数来表示yield的返回，一般我们也不会在自己的C函数里写协程就是了。<code>luaD_poscall(L, L-&gt;top - n);</code>则用来回复运行状态，包括CallInfo改回，savepc的改变等。在lua闭包里，其实也有，不过是在上一级函数的<code>luaV_execute(L, 1);</code>里执行到return系列字节码的时候。看来CallInfo也不是什么神奇的东西，只是存储函数的信息的结构体。</p>
<h2 id="luaB-coresume运行协程"><a href="#luaB-coresume运行协程" class="headerlink" title="luaB_coresume运行协程"></a>luaB_coresume运行协程</h2><p>有的时候，弄清结构以后，读源码真的不难。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_coresume</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  lua_State *co = lua_tothread(L, <span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  luaL_argcheck(L, co, <span class="number">1</span>, <span class="string">&quot;coroutine expected&quot;</span>);</span><br><span class="line">  r = auxresume(L, co, lua_gettop(L) - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    lua_pushboolean(L, <span class="number">0</span>);</span><br><span class="line">    lua_insert(L, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">/* return false + error message */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushboolean(L, <span class="number">1</span>);</span><br><span class="line">    lua_insert(L, -(r + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;  <span class="comment">/* return true + `resume&#x27; returns */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lua_State *co = lua_tothread(L, 1);</code>取出第一个协程参数，<code>auxresume</code>是执行的主体，r是yield传的参数个数，错误则返回一个负数，后面的栈操作，用于注入信息，我们看这个关键函数。  </p>
<figure class="highlight c"><figcaption><span>lbaselib.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">auxresume</span> <span class="params">(lua_State *L, lua_State *co, <span class="type">int</span> narg)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status = costatus(L, co);</span><br><span class="line">  <span class="keyword">if</span> (!lua_checkstack(co, narg))</span><br><span class="line">    luaL_error(L, <span class="string">&quot;too many arguments to resume&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (status != CO_SUS) &#123;</span><br><span class="line">    lua_pushfstring(L, <span class="string">&quot;cannot resume %s coroutine&quot;</span>, statnames[status]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* error flag */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_xmove(L, co, narg);</span><br><span class="line">  lua_setlevel(L, co);</span><br><span class="line">  status = lua_resume(co, narg);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="number">0</span> || status == LUA_YIELD) &#123;</span><br><span class="line">    <span class="type">int</span> nres = lua_gettop(co);</span><br><span class="line">    <span class="keyword">if</span> (!lua_checkstack(L, nres + <span class="number">1</span>))</span><br><span class="line">      luaL_error(L, <span class="string">&quot;too many results to resume&quot;</span>);</span><br><span class="line">    lua_xmove(co, L, nres);  <span class="comment">/* move yielded values */</span></span><br><span class="line">    <span class="keyword">return</span> nres;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_xmove(co, L, <span class="number">1</span>);  <span class="comment">/* move error message */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* error flag */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p><code>costatus(L, co);</code>返回co协程的状态，实现方式挺有趣的，注意协程处于初始化也属于suspended状态。后面检测参数是否超额和协程是否为suspended状态，只有suspended才能resume。<code>lua_xmove(L, co, narg);</code>用于两个协程间移动narg个参数。<code>lua_resume(co, narg);</code>是真正用来实现的函数，它与yield一样的，都提供了CAPI，我们搞嵌入开发时也能用的。有没有觉得lua比我们小心好多倍，一个函数套这么多皮，有点离谱哦。返回的是lua_State的状态，虽然协程是用lua_State实现的，但两者并不等价，之前创建的时候就说过了，lua_State状态如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread status; 0 is OK */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_YIELD       1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_ERRRUN      2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_ERRSYNTAX   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_ERRMEM      4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_ERRERR      5</span></span><br></pre></td></tr></table></figure>
<p>0表示正常，1表示挂起，其它用于表示各种错误，错误为什么分这么多，当然是为了便于调试了，以后再说。lua_resume返回0和yield，此函数正常执行，并通过<code>lua_xmove</code>将返回值移动。对于lua_resume的内容，就算不看都可以猜个大概了，就是两台虚拟机互相呼叫传参而已。</p>
<h2 id="luaB-yield挂起协程"><a href="#luaB-yield挂起协程" class="headerlink" title="luaB_yield挂起协程"></a>luaB_yield挂起协程</h2><p>这个简单得离谱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_yield</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lua_yield(L, lua_gettop(L));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止说我水段落，我就继续看看lua_yield的具体内容。  </p>
<figure class="highlight c"><figcaption><span>ldo.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_yield</span> <span class="params">(lua_State *L, <span class="type">int</span> nresults)</span> &#123;</span><br><span class="line">  luai_userstateyield(L, nresults);</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;nCcalls &gt; L-&gt;baseCcalls)</span><br><span class="line">    luaG_runerror(L, <span class="string">&quot;attempt to yield across metamethod/C-call boundary&quot;</span>);</span><br><span class="line">  L-&gt;base = L-&gt;top - nresults;  <span class="comment">/* protect stack slots below */</span></span><br><span class="line">  L-&gt;status = LUA_YIELD;</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p><code>luai_userstateyield</code>又是一个空函数，lua还真有趣。if用来报错，跳过。<code>L-&gt;base = L-&gt;top - nresults;</code>移动base准备接受resume的参数了，<code>L-&gt;status = LUA_YIELD;</code>修改协程为挂起状态，<code>return -1;</code>还记得之前的luaD_precall吗，里面不就有一个检测是否yield的语句嘛。看来yield的实现也就如此了。</p>
<h1 id="字符串的实现"><a href="#字符串的实现" class="headerlink" title="字符串的实现"></a>字符串的实现</h1><p>字符串为何如此重要，你可能觉得在c里不就是一个char*或char[]吗，其实gcc编译器隐藏了字符串在汇编下的表现，lua的实现类似于此，字符串的存储大有学问，准确来说，可变内存的对象处理都是不易的，cpu可没有智慧来看出字符串的长度，我们来看看lua如何存储字符串的。</p>
<h2 id="lua-pushlstring函数"><a href="#lua-pushlstring函数" class="headerlink" title="lua_pushlstring函数"></a>lua_pushlstring函数</h2><p>这是向栈压入string的核心方法，其它都基于此函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">void</span> <span class="title function_">lua_pushlstring</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  luaC_checkGC(L);</span><br><span class="line">  setsvalue2s(L, L-&gt;top, luaS_newlstr(L, s, len));</span><br><span class="line">  api_incr_top(L);</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了这么多lua源码的你，应该一眼就发现了<code>luaS_newlstr()</code>就是创建字符串的核心函数了。我们来深入了解一下它。  </p>
<figure class="highlight c"><figcaption><span>lstring.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TString *<span class="title function_">luaS_newlstr</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> l)</span> &#123;</span><br><span class="line">  GCObject *o;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h = cast(<span class="type">unsigned</span> <span class="type">int</span>, l);  <span class="comment">/* seed */</span></span><br><span class="line">  <span class="type">size_t</span> step = (l&gt;&gt;<span class="number">5</span>)+<span class="number">1</span>;  <span class="comment">/* if string is too long, don&#x27;t hash all its chars */</span></span><br><span class="line">  <span class="type">size_t</span> l1;</span><br><span class="line">  <span class="keyword">for</span> (l1=l; l1&gt;=step; l1-=step)  <span class="comment">/* compute hash */</span></span><br><span class="line">    h = h ^ ((h&lt;&lt;<span class="number">5</span>)+(h&gt;&gt;<span class="number">2</span>)+cast(<span class="type">unsigned</span> <span class="type">char</span>, str[l1<span class="number">-1</span>]));</span><br><span class="line">  <span class="keyword">for</span> (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];</span><br><span class="line">       o != <span class="literal">NULL</span>;</span><br><span class="line">       o = o-&gt;gch.next) &#123;</span><br><span class="line">    TString *ts = rawgco2ts(o);</span><br><span class="line">    <span class="keyword">if</span> (ts-&gt;tsv.len == l &amp;&amp; (<span class="built_in">memcmp</span>(str, getstr(ts), l) == <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">/* string may be dead */</span></span><br><span class="line">      <span class="keyword">if</span> (isdead(G(L), o)) changewhite(o);</span><br><span class="line">      <span class="keyword">return</span> ts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newlstr(L, str, l, h);  <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  

<p>返回值为TString，这就是lua用来存字符串的C结构体了。<code>GCObject *o;</code>创建可回收对象o。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> h = cast(<span class="type">unsigned</span> <span class="type">int</span>, l);  <span class="comment">/* seed */</span></span><br><span class="line"> <span class="type">size_t</span> step = (l&gt;&gt;<span class="number">5</span>)+<span class="number">1</span>;  <span class="comment">/* if string is too long, don&#x27;t hash all its chars */</span></span><br><span class="line"> <span class="type">size_t</span> l1;</span><br><span class="line"> <span class="keyword">for</span> (l1=l; l1&gt;=step; l1-=step)  <span class="comment">/* compute hash */</span></span><br><span class="line">   h = h ^ ((h&lt;&lt;<span class="number">5</span>)+(h&gt;&gt;<span class="number">2</span>)+cast(<span class="type">unsigned</span> <span class="type">char</span>, str[l1<span class="number">-1</span>]));</span><br></pre></td></tr></table></figure>
<p>这一段用于计算字符串的Hash值，最终将Hash值存入h。<br><code>for (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)]; o != NULL;o = o-&gt;gch.next)</code>比较复杂，我们分解来看。<code>G(L)-&gt;strt</code>是全局状态机中用于存储字符串的stringtable(字符串表)，<code>str.hash[]</code>即用来取出相应字符串(GCObject类型)。<code>strt.size</code>是字符串表的容量，<code>lmod</code>则用于对容量取模，保证数据在stringtable内的基本操作了。结合<code>o != NULL</code>，我们可以知道，如果hash位置非空当然话，我们取出<code>o-&gt;gch.next</code>，还非空则继续next。最终我们要取出空位置来存储数据。我们看看<code>gch.next</code>是什么东东。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeader    GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCheader</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">&#125; GCheader;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  GCheader gch;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">TString</span> <span class="title">ts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Udata</span> <span class="title">u</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Closure</span> <span class="title">cl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">h</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> <span class="title">uv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> <span class="title">th</span>;</span>  <span class="comment">/* thread */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仔细看看，其实就是每个基本的TString都会存一个空的GCObject指针，这其实是用于解决Hash冲突的基本方法—单向链表。<code>TString *ts = rawgco2ts(o);</code>将这块内存地址转化为TString类型，<code>ts-&gt;tsv.len == l</code>和<code>memcmp(str, getstr(ts), l)</code>则是比较内存大小，看是否能存此数据，通过则进行GC标记并返回对象指针。否则执行<code>newlstr(L, str, l, h)</code>来创建，具体如何，我们继续看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> TString *<span class="title function_">newlstr</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> l,</span></span><br><span class="line"><span class="params">                                       <span class="type">unsigned</span> <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  TString *ts;</span><br><span class="line">  stringtable *tb;</span><br><span class="line">  <span class="keyword">if</span> (l+<span class="number">1</span> &gt; (MAX_SIZET - <span class="keyword">sizeof</span>(TString))/<span class="keyword">sizeof</span>(<span class="type">char</span>))</span><br><span class="line">    luaM_toobig(L);</span><br><span class="line">  ts = cast(TString *, luaM_malloc(L, (l+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">char</span>)+<span class="keyword">sizeof</span>(TString)));</span><br><span class="line">  ts-&gt;tsv.len = l;</span><br><span class="line">  ts-&gt;tsv.hash = h;</span><br><span class="line">  ts-&gt;tsv.marked = luaC_white(G(L));</span><br><span class="line">  ts-&gt;tsv.tt = LUA_TSTRING;</span><br><span class="line">  ts-&gt;tsv.reserved = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(ts+<span class="number">1</span>, str, l*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  ((<span class="type">char</span> *)(ts+<span class="number">1</span>))[l] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">/* ending 0 */</span></span><br><span class="line">  tb = &amp;G(L)-&gt;strt;</span><br><span class="line">  h = lmod(h, tb-&gt;size);</span><br><span class="line">  ts-&gt;tsv.next = tb-&gt;hash[h];  <span class="comment">/* chain new entry */</span></span><br><span class="line">  tb-&gt;hash[h] = obj2gco(ts);</span><br><span class="line">  tb-&gt;nuse++;</span><br><span class="line">  <span class="keyword">if</span> (tb-&gt;nuse &gt; cast(lu_int32, tb-&gt;size) &amp;&amp; tb-&gt;size &lt;= MAX_INT/<span class="number">2</span>)</span><br><span class="line">    luaS_resize(L, tb-&gt;size*<span class="number">2</span>);  <span class="comment">/* too crowded */</span></span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建指针ts和tb，然后判断字符串长度是否过长，也就是lua字符串还有长度限制，实际就是size_t的大小，不同系统有些差异。继续看吧，<code>luaM_malloc</code>分配内存，大小是实际数据+用于封装的TString结构体，<code>l+1</code>是因为要存储<code>\\0</code>表示字符串结束，<code>ts+1</code>则表示跳过TString所占的内存。然后一系列初始化，<code>memcpy(ts+1, str, l*sizeof(char));((char *)(ts+1))[l] = &#39;\0&#39;;  /* ending 0 */</code>进行字符串数据的拷贝。然后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tb = &amp;G(L)-&gt;strt;</span><br><span class="line">h = lmod(h, tb-&gt;size);</span><br><span class="line">ts-&gt;tsv.next = tb-&gt;hash[h];  <span class="comment">/* chain new entry */</span></span><br><span class="line">tb-&gt;hash[h] = obj2gco(ts);</span><br><span class="line">tb-&gt;nuse++;</span><br></pre></td></tr></table></figure>
<p>则是将字符串放入全局状态机的stringtable。放入方式是更改相同Hash入口的TString，主要比较快，改改指针就行，放入末尾的话，还要遍历过去，不太方便。最后则是看nuse(个数)是否超过size(容量)，超过则进行扩容，都是常规操作了。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到这里其实就没什么重要的东西了。我们可以看到，lua中string的存储结构是TString加具体内容，原来我以为它在TString存了指向数据的指针，但并没有这样，可能是为了加快访问的速度吧。</p>
<h1 id="表的实现"><a href="#表的实现" class="headerlink" title="表的实现"></a>表的实现</h1><p>最后再来看看，我们几乎万能的表吧。表除了创建还有各种操作，我们逐个来解读。table比较特别，不能从C数据直接得到，所以我们从创建表的函数开始。</p>
<h2 id="lua-createtable函数"><a href="#lua-createtable函数" class="headerlink" title="lua_createtable函数"></a>lua_createtable函数</h2><p>至于<code>#define lua_newtable(L)         lua_createtable(L, 0, 0)</code>不讲也罢。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">void</span> <span class="title function_">lua_createtable</span> <span class="params">(lua_State *L, <span class="type">int</span> narray, <span class="type">int</span> nrec)</span> &#123;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  luaC_checkGC(L);</span><br><span class="line">  sethvalue(L, L-&gt;top, luaH_new(L, narray, nrec));</span><br><span class="line">  api_incr_top(L);</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入栈操作，主要函数还是<code>luaH_new(L, narray, nrec)</code>，来深入探究一下吧：  </p>
<figure class="highlight c"><figcaption><span>ltable.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Table *<span class="title function_">luaH_new</span> <span class="params">(lua_State *L, <span class="type">int</span> narray, <span class="type">int</span> nhash)</span> &#123;</span><br><span class="line">  Table *t = luaM_new(L, Table);</span><br><span class="line">  luaC_link(L, obj2gco(t), LUA_TTABLE);</span><br><span class="line">  t-&gt;metatable = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;flags = cast_byte(~<span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* temporary values (kept only if some malloc fails) */</span></span><br><span class="line">  t-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;sizearray = <span class="number">0</span>;</span><br><span class="line">  t-&gt;lsizenode = <span class="number">0</span>;</span><br><span class="line">  t-&gt;node = cast(Node *, dummynode);</span><br><span class="line">  setarrayvector(L, t, narray);</span><br><span class="line">  setnodevector(L, t, nhash);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p><code>Table *t = luaM_new(L, Table);</code>直接为Table分配内存并保存首地址，<code>luaC_link()</code>则将Table纳入回收对象。然后一系列的初值设定，node用于存储k-v形式的值，array用于存储顺序值，最后设置array和hash各部分的大小，基本都是置为lua里的nil类型，注意这与C里面的NULL是有区别的。实际上，如果看过字节码就会知道，创建表一般还要配OP_SETLIST来初始化array元素和OP_SETTABLE来初始化hash元素，我们来看看字节码吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_SETLIST: &#123;</span><br><span class="line">        <span class="type">int</span> n = GETARG_B(i);</span><br><span class="line">        <span class="type">int</span> c = GETARG_C(i);</span><br><span class="line">        <span class="type">int</span> last;</span><br><span class="line">        Table *h;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">          n = cast_int(L-&gt;top - ra) - <span class="number">1</span>;</span><br><span class="line">          L-&gt;top = L-&gt;ci-&gt;top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) c = cast_int(*pc++);</span><br><span class="line">        runtime_check(L, ttistable(ra));</span><br><span class="line">        h = hvalue(ra);</span><br><span class="line">        last = ((c<span class="number">-1</span>)*LFIELDS_PER_FLUSH) + n;</span><br><span class="line">        <span class="keyword">if</span> (last &gt; h-&gt;sizearray)  <span class="comment">/* needs more space? */</span></span><br><span class="line">          luaH_resizearray(L, h, last);  <span class="comment">/* pre-alloc it at once */</span></span><br><span class="line">        <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n--) &#123;</span><br><span class="line">          TValue *val = ra+n;</span><br><span class="line">          setobj2t(L, luaH_setnum(L, h, last--), val);</span><br><span class="line">          luaC_barriert(L, h, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_SETTABLE: &#123;</span><br><span class="line">        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>后一个比较简单，主要还是因为泛用性高，所有我们看前一个。ra是表在栈上的索引，n是要加入的元素个数，c的话好像用处不大，目前我见到的都是1，h用于存储要写入数据的表的指针。如果n=0，则准备将ra上的元素都写入表。<code>h = hvalue(ra);</code>取出我们之前创建的表，last似乎和表原来是否有初值有关c也是一样，但这个字节码，都是在空表之后，只能说这是程序员的严谨吧，虽然不太可能发生，但还是要检测，也就是last是扩充后表array部分的大小，不够则<code>luaH_resizearray</code>进行扩容。接下来就是for循环将栈上的值通过<code>luaH_setnum</code>来一个个写入表，从后往前写，这样可以顺便清理一下栈。</p>
<h2 id="元素获取"><a href="#元素获取" class="headerlink" title="元素获取"></a>元素获取</h2><p>由上部分，我们可以知道，往array里添元素的核心函数是<code>luaH_setnum</code>，我们来看看它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TValue *<span class="title function_">luaH_setnum</span> <span class="params">(lua_State *L, Table *t, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">const</span> TValue *p = luaH_getnum(t, key);</span><br><span class="line">  <span class="keyword">if</span> (p != luaO_nilobject)</span><br><span class="line">    <span class="keyword">return</span> cast(TValue *, p);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    TValue k;</span><br><span class="line">    setnvalue(&amp;k, cast_num(key));</span><br><span class="line">    <span class="keyword">return</span> newkey(L, t, &amp;k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数好理解，t是表，key是array的索引，看到这我们可以合理猜想array的长度不能超过int的最大值。返回TValue的指针，这其实是一个获得表对应位置指针的函数，修改实际在之前的函数<code>setobj2t</code>里完成的。第一步判断对应位置是否有值，没有则先创建key，是TValue类型中的number，接着通过newkey创建此key对应值的TValue，并返回。这样来看在lua里对表的索引不论array还是hash都是一样的，事实上，看过字节码的伙伴都知道，表索引使用的字节码其实都是OP_GETTABLE，我们来一看究竟吧，从字节码直接可以知道关键函数是<code>luaV_gettable</code>，它的源码如下：</p>
<figure class="highlight c"><figcaption><span>lvm.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaV_gettable</span> <span class="params">(lua_State *L, <span class="type">const</span> TValue *t, TValue *key, StkId val)</span> &#123;</span><br><span class="line">  <span class="type">int</span> loop;</span><br><span class="line">  <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; MAXTAGLOOP; loop++) &#123;</span><br><span class="line">    <span class="type">const</span> TValue *tm;</span><br><span class="line">    <span class="keyword">if</span> (ttistable(t)) &#123;  <span class="comment">/* `t&#x27; is a table? */</span></span><br><span class="line">      Table *h = hvalue(t);</span><br><span class="line">      <span class="type">const</span> TValue *res = luaH_get(h, key); <span class="comment">/* do a primitive get */</span></span><br><span class="line">      <span class="keyword">if</span> (!ttisnil(res) ||  <span class="comment">/* result is no nil? */</span></span><br><span class="line">          (tm = fasttm(L, h-&gt;metatable, TM_INDEX)) == <span class="literal">NULL</span>) &#123; <span class="comment">/* or no TM? */</span></span><br><span class="line">        setobj2s(L, val, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* else will try the tag method */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))</span><br><span class="line">      luaG_typeerror(L, t, <span class="string">&quot;index&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ttisfunction(tm)) &#123;</span><br><span class="line">      callTMres(L, val, tm, t, key);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = tm;  <span class="comment">/* else repeat with `tm&#x27; */</span> </span><br><span class="line">  &#125;</span><br><span class="line">  luaG_runerror(L, <span class="string">&quot;loop in gettable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数好理解，最后一个是索引后的TValue存放在栈上的相对位置。这个函数好复杂，似乎有好多功能，但这是笔者不太理解的，只知道索引的关键部分在<code>if(ttistable(t)) &#123;**&#125;</code>里面，似乎也只会用到这部分。内容简单明了，通过<code>luaH_get</code>获得TValue，没有问题则将表放入栈后，然后直接结束函数。更详细的索引也挺无聊的，根据TValue的类型不同，再分别调用不同的函数。</p>
<h2 id="表结构体"><a href="#表结构体" class="headerlink" title="表结构体"></a>表结构体</h2><p>我们没有看将表的移除的源码，对于array我们一般没有移除操作，实际上表是通过table库实现移除操作的，而移除操作实际是将值置为nil，实在没什么看点。我们稍微看看表的结构体吧。  </p>
<figure class="highlight c"><figcaption><span>lobject.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span> </span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of `node&#x27; array */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">  <span class="type">int</span> sizearray;  <span class="comment">/* size of `array&#x27; array */</span></span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure>  
<p>对于一份源码，读了大部分框架以后，再去细读还是挺索然无味的，因为我们大致都能预测该存储些什么了，而一些基础操作和我们平常写的也不会有太大区别。node和array分别存储hash和array部分的内容。lsizenode和sizearray存储相应部分的大小，metatable是元表信息，Node是由TKey和TValue组成的结构体。</p>
<h1 id="结尾-1"><a href="#结尾-1" class="headerlink" title="结尾"></a>结尾</h1><p>说实话，最后两部分还是挺失望的，本以为应该会有些有趣的思想在里面，但仔细一读，发现也就不过如此，但已经写了不少，就直接附上算了，对协程的理解才是这篇文章的主要部分。“大部分程序员都是做苦力的。”我似乎也属于这一梯度，我也是时候想要突破了。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lua/">lua</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">逯晓零</div><div class="author-info__description">我喜欢简洁，仅此而已。</div></div><div class="card-info-data site-data is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">协程的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">协程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua%E9%87%8C%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">lua里的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#coroutine-create"><span class="toc-number">1.4.1.</span> <span class="toc-text">coroutine.create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#coroutine-yield-%E2%80%A6-%E4%B8%8Ecoroutine-resume-co-%C2%B7%C2%B7%C2%B7"><span class="toc-number">1.4.2.</span> <span class="toc-text">coroutine.yield(…)与coroutine.resume (co , ···)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">官方案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">1.4.4.</span> <span class="toc-text">其它</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">2.</span> <span class="toc-text">协程的源码解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-newstate%E5%88%9B%E5%BB%BA%E4%B8%BB%E5%8D%8F%E7%A8%8B-lua%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">2.1.</span> <span class="toc-text">lua_newstate创建主协程(lua虚拟机)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#luaB-cocreate%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">luaB_cocreate创建协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CallInfo"><span class="toc-number">2.3.</span> <span class="toc-text">CallInfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#luaB-coresume%E8%BF%90%E8%A1%8C%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">luaB_coresume运行协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#luaB-yield%E6%8C%82%E8%B5%B7%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">luaB_yield挂起协程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">字符串的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-pushlstring%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">lua_pushlstring函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%B0%BE"><span class="toc-number">3.2.</span> <span class="toc-text">结尾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">表的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-createtable%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">lua_createtable函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96"><span class="toc-number">4.2.</span> <span class="toc-text">元素获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.3.</span> <span class="toc-text">表结构体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E5%B0%BE-1"><span class="toc-number">5.</span> <span class="toc-text">结尾</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2024-04-30-%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4-%E7%BC%96%E7%A8%8B%E5%88%B0%E5%BA%95%E8%AF%A5%E5%AD%A6%E4%BB%80%E4%B9%88/" title="随便说说--编程到底该学什么">随便说说--编程到底该学什么</a><time datetime="2024-04-29T23:54:07.000Z" title="发表于 2024-04-30 07:54:07">2024-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2024-03-31-%E6%A2%A6%E9%80%94%EF%BC%81%EF%BD%9E%E7%94%9F%E6%B4%BB%E5%B8%B8%E8%BD%A8%EF%BD%9E/" title="梦途！～生活常轨～">梦途！～生活常轨～</a><time datetime="2024-03-30T23:58:40.000Z" title="发表于 2024-03-31 07:58:40">2024-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2024-02-29-%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E9%82%A3%E4%BA%9B%E4%BA%8B/" title="毕业论文那些事">毕业论文那些事</a><time datetime="2024-02-29T07:24:09.000Z" title="发表于 2024-02-29 15:24:09">2024-02-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 逯晓零</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>