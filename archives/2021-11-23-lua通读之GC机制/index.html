<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>lua通读之GC机制 | 虚空之地</title><meta name="keywords" content="lua,内存"><meta name="author" content="逯晓零"><meta name="copyright" content="逯晓零"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="垃圾回收概述需求如果我们只是写一个如“Hello World”这般简单的程序话，垃圾回收本身就不是我们该考虑的问题，实际上，我们的程序是运行在操作系统上，当程序运行结束后，操作系统会自动回收所有程序使用的内存，也就是说，不是一直长时间运行的程序没有考虑垃圾回收的必要。同时，除了C和C++以外几乎所有语言都有垃圾回收机制，我们需要注意的是这里的垃圾回收本质指的是自动内存管理机制。C&#x2F;C++有相应的内">
<meta property="og:type" content="article">
<meta property="og:title" content="lua通读之GC机制">
<meta property="og:url" content="http://example.com/archives/2021-11-23-lua%E9%80%9A%E8%AF%BB%E4%B9%8BGC%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="虚空之地">
<meta property="og:description" content="垃圾回收概述需求如果我们只是写一个如“Hello World”这般简单的程序话，垃圾回收本身就不是我们该考虑的问题，实际上，我们的程序是运行在操作系统上，当程序运行结束后，操作系统会自动回收所有程序使用的内存，也就是说，不是一直长时间运行的程序没有考虑垃圾回收的必要。同时，除了C和C++以外几乎所有语言都有垃圾回收机制，我们需要注意的是这里的垃圾回收本质指的是自动内存管理机制。C&#x2F;C++有相应的内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-11-23T11:33:40.000Z">
<meta property="article:modified_time" content="2023-09-03T13:50:19.104Z">
<meta property="article:author" content="逯晓零">
<meta property="article:tag" content="lua">
<meta property="article:tag" content="内存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/archives/2021-11-23-lua%E9%80%9A%E8%AF%BB%E4%B9%8BGC%E6%9C%BA%E5%88%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'lua通读之GC机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-03 21:50:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/articles/"><i class="fa-fw fa fa-book"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/dream/"><i class="fa-fw fa fa-lightbulb"></i><span> 绘梦</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">虚空之地</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/articles/"><i class="fa-fw fa fa-book"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/dream/"><i class="fa-fw fa fa-lightbulb"></i><span> 绘梦</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">lua通读之GC机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-23T11:33:40.000Z" title="发表于 2021-11-23 19:33:40">2021-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-03T13:50:19.104Z" title="更新于 2023-09-03 21:50:19">2023-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>如果我们只是写一个如“Hello World”这般简单的程序话，垃圾回收本身就不是我们该考虑的问题，实际上，我们的程序是运行在操作系统上，当程序运行结束后，操作系统会自动回收所有程序使用的内存，也就是说，不是一直长时间运行的程序没有考虑垃圾回收的必要。同时，除了C和C++以外几乎所有语言都有垃圾回收机制，我们需要注意的是这里的垃圾回收本质指的是自动内存管理机制。C/C++有相应的内存管理接口，但需要手动。而其它大部分语言没有提供内存管理接口，都是自动管理，就是我们通常所说的拥有垃圾回收机制。<br>虽然我们可以使用更多拥有良好GC机制的语言进行高效编程，但C/C++可以说是所有高级语言的老祖宗了，大部分语言的解释器都依赖与C/C++实现，其实C才比较正确，C++提供面向对象的特性，同时提供了析构函数用于自动回收对象，注意是对象，对象里的数据则通过编写析构函数来回收。  </p>
<h2 id="学习GC原理"><a href="#学习GC原理" class="headerlink" title="学习GC原理"></a>学习GC原理</h2><p>不论我们学习多少语言，会发现它们都提供了与C/C++交互的机制，或载入C/C++库的机制，比如java的jni，目的都说是提高效率。总之，我们终会使用C/C++，所以了解一些垃圾回收的方式还是有必要的。</p>
<h1 id="lua的基本API"><a href="#lua的基本API" class="headerlink" title="lua的基本API"></a>lua的基本API</h1><p>在学习源码之前，我们先来稍微体会一下lua脚本里面GC的使用，我们使用collectgarbage这一个函数即可。<br><code>collectgarbage(&quot;collect&quot;)</code>进行一次手动垃圾回收，<code>collectgarbage(&quot;stop&quot;)</code>停止自动垃圾回收，<code>collectgarbage(&quot;restart&quot;)</code>重启垃圾回收器，<code>collectgarbage(&quot;count&quot;)</code>返回Lua使用的总内存，至于后面的指令，我们得稍微了解一下lua的垃圾回收机制了，根据官方文档lua采用的是incremental mark-and-sweep collector(渐进式标记-清除回收器)，我们需要分开来看。</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记：即标记不需要回收的对象。有两个部分，一是从根节点遍历可到达对象并标记，二是去除用户手动置空对象的标记，在lua里标记的颜色较多，我们等下说。<br>清除：即清除没有标记的对象并清除标记，最后还能选择的加一个收尾函数进行些可能需要的处理。</p>
<h2 id="渐进式"><a href="#渐进式" class="headerlink" title="渐进式"></a>渐进式</h2><p>lua的垃圾回收器，有两个控制参数mul和pause。对于每次标记-清除的程度不同，依据内存分配的多少来决定多大程度，它的参数是mul，而每次标记-清除属于step，众多的step组成一次collect，每次collect的间隔为pause。pause和mul的单位为100。这些有点抽象我们将源码的时候再更详细的去了解。到这里，我们就知道接下来的几个函数的意义了，<code>collectgarbage(&quot;step&quot;,n)</code>执行n次step，<code>collectgarbage(&quot;setpause&quot;,n)</code>设置回收器的pause为n/100，<code>collectgarbage(&quot;setstepmul&quot;,n)</code>设置回收器的mul为n/100。为了深入理解，我们还是来看看lua垃圾回收的源码吧。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><p>在源码解读前，我们先稍微提一下C语言中有哪些对象是需要回收的。C语言需要回收的是堆内存，而栈内存会在函数结束后自动回收。其实就是通过<code>calloc</code>和<code>malloc</code>分配的内存，主要用的多的是后者，而对于在函数内的<code>int i=0</code>之类的内存则会在函数结束后回收。其实还有全局变量，但所谓的垃圾指的一般是我们没有访问到这块内存的指针，同时它属于动态内存可能有不断扩大的风险，对于全局变量内存一般是固定的没有管理的必要性。</p>
<h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><p>一个进程的基本内存有四部分，代码区，全局变量区，栈区和堆区。我们发现这与lua虚拟机惊人的相似，只不过多了一个堆区。实际上，在操作系统上运行的程序，也相当于在系统这个虚拟机上运行的，几乎所有虚拟机都一个样，没什么好说的。我们主要看堆区的内存，这才是需要管理的部分。<br>在lua占用堆内存的是lightuserdate和GCObject，但我见到的都是GCObject，GCObject是一个联合体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  GCheader gch;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">TString</span> <span class="title">ts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Udata</span> <span class="title">u</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Closure</span> <span class="title">cl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">h</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> <span class="title">uv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> <span class="title">th</span>;</span>  <span class="comment">/* thread */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说lua将所有堆内存的数据都抽象为一个GCObject来管理，具体的内容如上。global_State并没有包含进去，从它的结构体申明也可以发现它没有CommonHeader。由之前的分析也可以知道，这块内存是挂载到主协程上管理的。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>在各种头文件里，我们并没有发现垃圾回收器的结构体，那它的状态pause和mul保存在哪里呢，我们只能去<code>collectgarbage</code>函数在C里的表现来探究了。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_collectgarbage</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> opts[] = &#123;<span class="string">&quot;stop&quot;</span>, <span class="string">&quot;restart&quot;</span>, <span class="string">&quot;collect&quot;</span>,</span><br><span class="line">    <span class="string">&quot;count&quot;</span>, <span class="string">&quot;step&quot;</span>, <span class="string">&quot;setpause&quot;</span>, <span class="string">&quot;setstepmul&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> optsnum[] = &#123;LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,</span><br><span class="line">    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL&#125;;</span><br><span class="line">  <span class="type">int</span> o = luaL_checkoption(L, <span class="number">1</span>, <span class="string">&quot;collect&quot;</span>, opts);</span><br><span class="line">  <span class="type">int</span> ex = luaL_optint(L, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> res = lua_gc(L, optsnum[o], ex);</span><br><span class="line">  <span class="keyword">switch</span> (optsnum[o]) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCCOUNT: &#123;</span><br><span class="line">      <span class="type">int</span> b = lua_gc(L, LUA_GCCOUNTB, <span class="number">0</span>);</span><br><span class="line">      lua_pushnumber(L, res + ((lua_Number)b/<span class="number">1024</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCSTEP: &#123;</span><br><span class="line">      lua_pushboolean(L, res);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      lua_pushnumber(L, res);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易看出核心语句是<code>int res = lua_gc(L, optsnum[o], ex);</code>，optsum是垃圾回收的指令，ex是额外的参数，res是返回值。最后的switch则根据指令的不同将不同的结果入栈。我们注意到获取使用内存时，有两部分—LUA_GCCOUNT和LUA_GCCOUNTB，后面我们会看到它们的区别。  </p>
<figure class="highlight c"><figcaption><span>lapi.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_gc</span> <span class="params">(lua_State *L, <span class="type">int</span> what, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  global_State *g;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  g = G(L);</span><br><span class="line">  <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCSTOP: &#123;</span><br><span class="line">      g-&gt;GCthreshold = MAX_LUMEM;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCRESTART: &#123;</span><br><span class="line">      g-&gt;GCthreshold = g-&gt;totalbytes;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCCOLLECT: &#123;</span><br><span class="line">      luaC_fullgc(L);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCCOUNT: &#123;</span><br><span class="line">      <span class="comment">/* GC values are expressed in Kbytes: #bytes/2^10 */</span></span><br><span class="line">      res = cast_int(g-&gt;totalbytes &gt;&gt; <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCCOUNTB: &#123;</span><br><span class="line">      res = cast_int(g-&gt;totalbytes &amp; <span class="number">0x3ff</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCSTEP: &#123;</span><br><span class="line">      lu_mem a = (cast(lu_mem, data) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">if</span> (a &lt;= g-&gt;totalbytes)</span><br><span class="line">        g-&gt;GCthreshold = g-&gt;totalbytes - a;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        g-&gt;GCthreshold = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (g-&gt;GCthreshold &lt;= g-&gt;totalbytes) &#123;</span><br><span class="line">        luaC_step(L);</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;gcstate == GCSpause) &#123;  <span class="comment">/* end of cycle? */</span></span><br><span class="line">          res = <span class="number">1</span>;  <span class="comment">/* signal it */</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCSETPAUSE: &#123;</span><br><span class="line">      res = g-&gt;gcpause;</span><br><span class="line">      g-&gt;gcpause = data;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GCSETSTEPMUL: &#123;</span><br><span class="line">      res = g-&gt;gcstepmul;</span><br><span class="line">      g-&gt;gcstepmul = data;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: res = <span class="number">-1</span>;  <span class="comment">/* invalid option */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p>我们从这里可以看到不少东西，比如pause和mul是存储在全局状态机里，连使用的内存也存在里面，而LUA_GCCOUNT和LUA_GCCOUNTB只是为了把内存的kb和byte区分处理，在全局状态机里存储内存的单位是byte而输出则是kbyte。实际上连垃圾回收器的状态也存储在全局状态机上，我们通过g-&gt;GCthreshold改变垃圾回收器的运行状态，注意这和状态不同，g-&gt;gcstate是gc运行过程中的状态，标志当前回收处于哪个阶段，有以下这些类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GCSpause        0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GCSpropagate    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GCSsweepstring  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GCSsweep        3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GCSfinalize     4</span></span><br></pre></td></tr></table></figure>
<p>对于collect则会执行一次fullgc，不过我们还是先看一下step的执行。首先对于GCthreshold得讲一下，由之前的代码可知GCthreshold等于MAX_LUMEM时表示回收器停止，这个MAX_LUMEM是unsignedlong的最大值，应该基本达不到这么大的内存，而GCthreshold等于totalbytes表示垃圾回收器在正常执行。好了回到我们的step，首先将步数data扩大1024倍，之前说过回收与内存有关，接下来就是与总内存比较，过多则GCthreshold直接清零，否则在GCthreshold内去除相应大小，<code>luaC_step(L);</code>实现清理的方法，结果是使得GCthreshold超过totalbytes，实际上我们是通过减少totalbytes达到这一步的，另一个if判断垃圾回收器是否pause，不是太重要。我们来看看<code>luaC_step(L)</code>的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaC_step</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  l_mem lim = (GCSTEPSIZE/<span class="number">100</span>) * g-&gt;gcstepmul;</span><br><span class="line">  <span class="keyword">if</span> (lim == <span class="number">0</span>)</span><br><span class="line">    lim = (MAX_LUMEM<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">/* no limit */</span></span><br><span class="line">  g-&gt;gcdept += g-&gt;totalbytes - g-&gt;GCthreshold;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    lim -= singlestep(L);</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gcstate == GCSpause)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (lim &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gcstate != GCSpause) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gcdept &lt; GCSTEPSIZE)</span><br><span class="line">      g-&gt;GCthreshold = g-&gt;totalbytes + GCSTEPSIZE;  <span class="comment">/* - lim/g-&gt;gcstepmul;*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      g-&gt;gcdept -= GCSTEPSIZE;</span><br><span class="line">      g-&gt;GCthreshold = g-&gt;totalbytes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    setthreshold(g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先由mul参数计算lim，0表示没有限制。接着由totalbytes和GCthreshold的差，确定计划回收多少内存，注意这里只是一个step，gcdept还残留着之前的数据。<code>singlestep</code>才是最终的回收函数，它会根据此时全局状态机上挂的各种参数来回收相应内存，返回值是回收了具体多少内存，这里有关pause的判定，与之前类似，这里的目的是将lim降为非正数，接下来就是一些收尾内容，调整相关参数。在此之前，我们来看一看<code>luaC_fullgc</code>与此的差别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaC_fullgc</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gcstate &lt;= GCSpropagate) &#123;</span><br><span class="line">    <span class="comment">/* reset sweep marks to sweep all elements (returning them to white) */</span></span><br><span class="line">    g-&gt;sweepstrgc = <span class="number">0</span>;</span><br><span class="line">    g-&gt;sweepgc = &amp;g-&gt;rootgc;</span><br><span class="line">    <span class="comment">/* reset other collector lists */</span></span><br><span class="line">    g-&gt;gray = <span class="literal">NULL</span>;</span><br><span class="line">    g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">    g-&gt;weak = <span class="literal">NULL</span>;</span><br><span class="line">    g-&gt;gcstate = GCSsweepstring;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert(g-&gt;gcstate != GCSpause &amp;&amp; g-&gt;gcstate != GCSpropagate);</span><br><span class="line">  <span class="comment">/* finish any pending sweep phase */</span></span><br><span class="line">  <span class="keyword">while</span> (g-&gt;gcstate != GCSfinalize) &#123;</span><br><span class="line">    lua_assert(g-&gt;gcstate == GCSsweepstring || g-&gt;gcstate == GCSsweep);</span><br><span class="line">    singlestep(L);</span><br><span class="line">  &#125;</span><br><span class="line">  markroot(L);</span><br><span class="line">  <span class="keyword">while</span> (g-&gt;gcstate != GCSpause) &#123;</span><br><span class="line">    singlestep(L);</span><br><span class="line">  &#125;</span><br><span class="line">  setthreshold(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步用于清除状态，准备开始FullGC，对于lua_assert没什么，要你自己去加。接下来不断执行<code>singlestep(L);</code>直到GCSfinalize状态，注意这里只是为了结束之前未完成的清理。接下来<code>markroot(L)</code>开始标记，while则依赖<code>singlestep(L);</code>执行清除操作，直到GCSpause表示一个周期结束。最后，我们还要看一下<code>luaC_checkGC(L)</code>这是一个lua虚拟机内容改变时经常调用的函数，如字符串入栈。它是一个宏，定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> luaC_checkGC(L) &#123; \</span></span><br><span class="line"><span class="meta">  condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize - EXTRA_STACK - 1)); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (G(L)-&gt;totalbytes &gt;= G(L)-&gt;GCthreshold) \</span></span><br><span class="line"><span class="meta">        luaC_step(L); &#125;</span></span><br></pre></td></tr></table></figure>
<p>里面的<code>luaC_step()</code>我们已经见过了，表示执行一次step，至此我们已经大概明白自动垃圾回收是怎么回事了，在lua里并非有一个专门的线程来垃圾回收，而是在有些lua操作的时候，通过调用垃圾回收函数来实现的。</p>
<h2 id="markroot函数"><a href="#markroot函数" class="headerlink" title="markroot函数"></a>markroot函数</h2><p>在看回收函数前，我们有必要先来看看lua是如何标记元素的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">markroot</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  g-&gt;gray = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;weak = <span class="literal">NULL</span>;</span><br><span class="line">  markobject(g, g-&gt;mainthread);</span><br><span class="line">  <span class="comment">/* make global table be traversed before main stack */</span></span><br><span class="line">  markvalue(g, gt(g-&gt;mainthread));</span><br><span class="line">  markvalue(g, registry(L));</span><br><span class="line">  markmt(g);</span><br><span class="line">  g-&gt;gcstate = GCSpropagate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先获取全局状态机，然后清除所有标记，然后mark*()则是进行标记的核心函数，总共有四个部分，我们一一来看。</p>
<h3 id="markobject函数"><a href="#markobject函数" class="headerlink" title="markobject函数"></a>markobject函数</h3><p>这是一个宏，注意我们传入了主虚拟机L为t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> markobject(g,t) &#123; <span class="keyword">if</span> (iswhite(obj2gco(t))) \</span></span><br><span class="line"><span class="meta">                reallymarkobject(g, obj2gco(t)); &#125;</span></span><br></pre></td></tr></table></figure>
<p>iswhite可以先不管，我们看reallymarkobject的内容，注意这里使用obj2gco进行类型转化，等价于cast。  </p>
<figure class="highlight c"><figcaption><span>lgc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reallymarkobject</span> <span class="params">(global_State *g, GCObject *o)</span> &#123;</span><br><span class="line">  lua_assert(iswhite(o) &amp;&amp; !isdead(g, o));</span><br><span class="line">  white2gray(o);</span><br><span class="line">  <span class="keyword">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSTRING: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TUSERDATA: &#123;</span><br><span class="line">      Table *mt = gco2u(o)-&gt;metatable;</span><br><span class="line">      gray2black(o);  <span class="comment">/* udata are never gray */</span></span><br><span class="line">      <span class="keyword">if</span> (mt) markobject(g, mt);</span><br><span class="line">      markobject(g, gco2u(o)-&gt;env);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TUPVAL: &#123;</span><br><span class="line">      UpVal *uv = gco2uv(o);</span><br><span class="line">      markvalue(g, uv-&gt;v);</span><br><span class="line">      <span class="keyword">if</span> (uv-&gt;v == &amp;uv-&gt;u.value)  <span class="comment">/* closed? */</span></span><br><span class="line">        gray2black(o);  <span class="comment">/* open upvalues are never black */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TFUNCTION: &#123;</span><br><span class="line">      gco2cl(o)-&gt;c.gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TTABLE: &#123;</span><br><span class="line">      gco2h(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TTHREAD: &#123;</span><br><span class="line">      gco2th(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TPROTO: &#123;</span><br><span class="line">      gco2p(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: lua_assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p>在开始解读前，我们先说两个东西。不知道你是否还记得在GCObject联合体的申明里面有一个GCheader的部分，它的内容其实就是封装CommonHeader的一个结构体，没错就是每个可回收对象的共有开头，不知道你有没有发觉出什么？其实这里是一项非常有趣的技术，这里运用了联合体内存共享的机制，GCheader和具体对象的CommonHeader共享同一块内存，我们访问GCObject的gch就可以访问到具体对象CommonHeader里的内容了，因此我们就能将可回收对象转化为GCObject进行统一处理了，的确值得好好学习。<br>接下来再对CommonHeader里的marked稍加说明，它的类型是lu_byte，实际上就是unsigned char，不过只要记住它是个8位二进制数就行了，也就是说它可以标记8个状态，有下面这些</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE0BIT       0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE1BIT       1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACKBIT        2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FINALIZEDBIT    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYWEAKBIT      3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VALUEWEAKBIT    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIXEDBIT        5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SFIXEDBIT       6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITEBITS       bit2mask(WHITE0BIT, WHITE1BIT)</span></span><br></pre></td></tr></table></figure>
<p>lua里面用到的就只要7位，bit2mask函数是一个宏用于将后面两个标志结合到一起，实现比较简单，对于每一个标志可以通过1&lt;&lt;“相应数字”来得到标志位，然后再使用“|”按位与运算即可得到最后的标志位。标志位的具体意思，稍微等等，我们只要先记住SFIXEDBIT只有主协程才有就行了。<br>好了回到我们的函数，<code>white2gray(o)</code>给o标记上WHITE0BIT和WHITE1BIT，即WHITEBITS，接下来判断o的类型，虽然我们入口传入的是lua主协程，但这个函数是广泛适用的，所以需要判断。对于字符串并没有做标记，这就是为什么状态里有sweep和sweepstring了。如果是userdata，将metatable部分标黑后，将它的两部分分别再进行标记，一个典型的递归。对于upval，使用markvalue标记它的值，因为具体无法确定，只知道它是TValue，但本质也是调用markobject，接下来判断是否为自身，如果是则将其标黑，则主要防止不断上传导致无限循环一直都无法标记。接下来几种数据类型内部也会有许多可回收对象，故将其的gclist挂到全局状态机的gray上，方式与之前TString处理Hash冲突的方式相同。  </p>
<h3 id="markvalue函数和markmt函数"><a href="#markvalue函数和markmt函数" class="headerlink" title="markvalue函数和markmt函数"></a>markvalue函数和markmt函数</h3><p>这两个函数本身没什么好说的，也是通过调用reallymarkobject函数实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> markvalue(g,o) &#123; checkconsistency(o); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (iscollectable(o) &amp;&amp; iswhite(gcvalue(o))) reallymarkobject(g,gcvalue(o)); &#125;</span></span><br></pre></td></tr></table></figure>
<p>参数gt(g-&gt;mainthread)表示lua虚拟机的所有全局表，registry(L)则是全局表_G，它是挂载在全局状态机上面的。对于主协程没有太大区别，但我们还有协程，所以挂在虚拟机上和全局状态机上是不同的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">markmt</span> <span class="params">(global_State *g)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_TAGS; i++)</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;mt[i]) markobject(g, g-&gt;mt[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数则是用于标记全局状态机的元表。后两部分加起来可以发现与对userdate的处理是类似的，全局表与一般表的区别是它挂载的位置不同。<br>由以上分析可以知道，我们标记主要有两大成分，一是主协程上的gclist和全局表，二是全局状态机上的全局表和元表。</p>
<h2 id="singlestep函数"><a href="#singlestep函数" class="headerlink" title="singlestep函数"></a>singlestep函数</h2><p>通过之前的分析可以知道此函数用于执行一次step，但这个step与collectgarbage(“step”)有些不太一样。  </p>
<figure class="highlight c"><figcaption><span>lgc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> l_mem <span class="title function_">singlestep</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="comment">/*lua_checkmemory(L);*/</span></span><br><span class="line">  <span class="keyword">switch</span> (g-&gt;gcstate) &#123;</span><br><span class="line">    <span class="keyword">case</span> GCSpause: &#123;</span><br><span class="line">      markroot(L);  <span class="comment">/* start a new collection */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GCSpropagate: &#123;</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;gray)</span><br><span class="line">        <span class="keyword">return</span> propagatemark(g);</span><br><span class="line">      <span class="keyword">else</span> &#123;  <span class="comment">/* no more `gray&#x27; objects */</span></span><br><span class="line">        atomic(L);  <span class="comment">/* finish mark phase */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GCSsweepstring: &#123;</span><br><span class="line">      lu_mem old = g-&gt;totalbytes;</span><br><span class="line">      sweepwholelist(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc++]);</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;sweepstrgc &gt;= g-&gt;strt.size)  <span class="comment">/* nothing more to sweep? */</span></span><br><span class="line">        g-&gt;gcstate = GCSsweep;  <span class="comment">/* end sweep-string phase */</span></span><br><span class="line">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class="line">      <span class="keyword">return</span> GCSWEEPCOST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GCSsweep: &#123;</span><br><span class="line">      lu_mem old = g-&gt;totalbytes;</span><br><span class="line">      g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX);</span><br><span class="line">      <span class="keyword">if</span> (*g-&gt;sweepgc == <span class="literal">NULL</span>) &#123;  <span class="comment">/* nothing more to sweep? */</span></span><br><span class="line">        checkSizes(L);</span><br><span class="line">        g-&gt;gcstate = GCSfinalize;  <span class="comment">/* end sweep phase */</span></span><br><span class="line">      &#125;</span><br><span class="line">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class="line">      <span class="keyword">return</span> GCSWEEPMAX*GCSWEEPCOST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GCSfinalize: &#123;</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;tmudata) &#123;</span><br><span class="line">        GCTM(L);</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;estimate &gt; GCFINALIZECOST)</span><br><span class="line">          g-&gt;estimate -= GCFINALIZECOST;</span><br><span class="line">        <span class="keyword">return</span> GCFINALIZECOST;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        g-&gt;gcstate = GCSpause;  <span class="comment">/* end collection */</span></span><br><span class="line">        g-&gt;gcdept = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: lua_assert(<span class="number">0</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p>先判断处于回收的哪个阶段，如果是pause阶段，则标记根节点。注意我们只标记了根节点，而“标记-回收算法”还需要将可到达元素标记，由之前分析可知，我们执行<code>markroot</code>后，回收将进入propagate状态，意思即为增殖。如果处于propagate状态，观察全局状态机的grey是否有值，有则执行propagatemark进行增殖标记，否则结束执行atomic结束标记过程，执行atomic后会进入sweepstring阶段，等下我们会分析的。如果回收器处于sweepstring阶段，则使用sweepwholelist进行真正的回收操作，它每次会在全局状态机的字符串表strt上移动一次，然后计算清理前后的内存差，并令全局状态机的estimate减去相应内存，当然这并不重要。最后如果strt遍历结束，则进入sweep阶段。对于sweep阶段与上一个类似，只不过遍历的是全局状态机的sweepgc，sweepgc是包含所有可回收对象的表的指针(也可以称为数组)，这是什么意思？在lua里所有回收对象类似于树林的存储方式，所有根节点组成全局状态机里的rootgc，而处于同一深度的元素通过next互相联系，它们组成一个链表用于我们进行每次sweeplist，并返回下一个sweeplist，达到最深以后进入finalize阶段。如果处于finalize阶段，则通过GCTM清理全局状态机的userdata，tmudata是所有userdata的链表，此表遍历结束则进入pause。至此singlestep方法结束。<br>对于接下来各种函数再具体分析无聊且没太大意义，这里我们总结一下。lua总共有三种颜色标记，可以通过is*看它们的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> iswhite(x)      test2bits((x)-&gt;gch.marked, WHITE0BIT, WHITE1BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isblack(x)      testbit((x)-&gt;gch.marked, BLACKBIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isgray(x)       (!isblack(x) &amp;&amp; !iswhite(x))</span></span><br></pre></td></tr></table></figure>
<p>任何对象初始均为白色标记，在markobject通过white2gray标灰，灰表示所有有引用的对象，在propagatemark我们则通过gray2black标黑，黑表示强引用，所以在markobject里可以直接将userdata和upval标黑，它一定不会被回收，propagatemark里面还通过调用traversestack来实现遍历其它节点。在propagatemark主要判断table,function,thread和proto，其中有标回灰色的倾向，主要针对弱引用，其出现在表和协程的结构里面，主要是在C里表现为存在GCObject的指针，注意function和proto没有此倾向，其内部数据依赖于自身的栈和固有的常量表，执行完就可以回收，不存在弱引用现象。sweepwholelist本质是调用sweeplist并输入最大数，sweeplist遍历传入的链表，清除白色标记(等于没标记)的实体，还有一个遍历的上限。</p>
<h2 id="源码总结"><a href="#源码总结" class="headerlink" title="源码总结"></a>源码总结</h2><p>我们前面大部分都专注于“标记-回收”部分，而对于gclist，sweepgc等的构建过程，我们没有过多的解读，主要这并非垃圾回收的主要部分，实在不行的话，其实直接将所有GCObject放入一个链表里都可以，但lua的gc过程所要求的结构并非这样，也就是说gc过程决定对象的存储结构，读了gc过程自然也好猜出构建的过程。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>到这里，我们已经对lua的整个垃圾回收机制有了一个大体的认识，不过我们还是需要时刻谨记我们读源码的目的是什么？更好的利用和学习有参考意义的算法，而对于一些细枝末节是我们需要在实战中不断注意提升的，至于自己也能想到的东西一遍过就足矣了。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lua/">lua</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98/">内存</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">逯晓零</div><div class="author-info__description">我喜欢简洁，仅此而已。</div></div><div class="card-info-data site-data is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">垃圾回收概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0GC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">学习GC原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lua%E7%9A%84%E5%9F%BA%E6%9C%ACAPI"><span class="toc-number">2.</span> <span class="toc-text">lua的基本API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">渐进式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.</span> <span class="toc-text">C语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">3.2.</span> <span class="toc-text">内存分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#markroot%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">markroot函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#markobject%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">markobject函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#markvalue%E5%87%BD%E6%95%B0%E5%92%8Cmarkmt%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.2.</span> <span class="toc-text">markvalue函数和markmt函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#singlestep%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">singlestep函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">源码总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E5%B0%BE"><span class="toc-number">4.</span> <span class="toc-text">结尾</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2024-02-29-%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E9%82%A3%E4%BA%9B%E4%BA%8B/" title="毕业论文那些事">毕业论文那些事</a><time datetime="2024-02-29T07:24:09.000Z" title="发表于 2024-02-29 15:24:09">2024-02-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2024-01-31-%E5%8F%8D%E5%8F%8D%E5%A4%8D%E5%A4%8D%E7%9A%84%E7%BB%88%E7%BB%93/" title="反反复复的终结">反反复复的终结</a><time datetime="2024-01-31T01:41:53.000Z" title="发表于 2024-01-31 09:41:53">2024-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2023-12-31-%E6%88%91%E4%B8%8E%E6%88%91%E6%89%80%E7%88%B1%E7%9A%84Galgame%E4%BB%AC/" title="Galgame--...">Galgame--...</a><time datetime="2023-12-31T11:10:23.000Z" title="发表于 2023-12-31 19:10:23">2023-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 逯晓零</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>