<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>lua通读之lua源码分析 | 虚空之地</title><meta name="keywords" content="lua,源码"><meta name="author" content="逯晓零"><meta name="copyright" content="逯晓零"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言终于来到我盼望已久的源码阅读了，但我又开始思考一个我经常问的问题，源码该怎么读？是否要全读一遍呢？比如我们的lua是一个类编译器，有必要去读大家都学过的词法分析和句法分析部分吗？读源码要从入口函数main开始吗？读源码更重要的是读出思想，如果不懂得几种程序的设计模式没有摆脱以往的思想，你会发现java源码，怎么也读不懂，甚至会觉得莫名其妙。实际上理解设计模式的好处，就能体会更加高效的编程，这才">
<meta property="og:type" content="article">
<meta property="og:title" content="lua通读之lua源码分析">
<meta property="og:url" content="http://example.com/archives/2021-11-10-lua%E9%80%9A%E8%AF%BB%E4%B9%8Blua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="虚空之地">
<meta property="og:description" content="前言终于来到我盼望已久的源码阅读了，但我又开始思考一个我经常问的问题，源码该怎么读？是否要全读一遍呢？比如我们的lua是一个类编译器，有必要去读大家都学过的词法分析和句法分析部分吗？读源码要从入口函数main开始吗？读源码更重要的是读出思想，如果不懂得几种程序的设计模式没有摆脱以往的思想，你会发现java源码，怎么也读不懂，甚至会觉得莫名其妙。实际上理解设计模式的好处，就能体会更加高效的编程，这才">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-11-09T23:47:31.000Z">
<meta property="article:modified_time" content="2022-10-14T23:47:06.798Z">
<meta property="article:author" content="逯晓零">
<meta property="article:tag" content="lua">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/archives/2021-11-10-lua%E9%80%9A%E8%AF%BB%E4%B9%8Blua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'lua通读之lua源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-15 07:47:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/words/"><i class="fa-fw fa fa-snowflake"></i><span> 动态</span></a></div><div class="menus_item"><a class="site-page" href="/articles/"><i class="fa-fw fa fa-book"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/dream/"><i class="fa-fw fa fa-lightbulb"></i><span> 绘梦</span></a></div><div class="menus_item"><a class="site-page" href="/retrieval/"><i class="fa-fw fa fa-search"></i><span> 检索</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">虚空之地</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/words/"><i class="fa-fw fa fa-snowflake"></i><span> 动态</span></a></div><div class="menus_item"><a class="site-page" href="/articles/"><i class="fa-fw fa fa-book"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/dream/"><i class="fa-fw fa fa-lightbulb"></i><span> 绘梦</span></a></div><div class="menus_item"><a class="site-page" href="/retrieval/"><i class="fa-fw fa fa-search"></i><span> 检索</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">lua通读之lua源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-09T23:47:31.000Z" title="发表于 2021-11-10 07:47:31">2021-11-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-14T23:47:06.798Z" title="更新于 2022-10-15 07:47:06">2022-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于来到我盼望已久的源码阅读了，但我又开始思考一个我经常问的问题，源码该怎么读？是否要全读一遍呢？比如我们的lua是一个类编译器，有必要去读大家都学过的词法分析和句法分析部分吗？读源码要从入口函数main开始吗？读源码更重要的是读出思想，如果不懂得几种程序的设计模式没有摆脱以往的思想，你会发现java源码，怎么也读不懂，甚至会觉得莫名其妙。实际上理解设计模式的好处，就能体会更加高效的编程，这才是我们学习的目的。<br>读源码，我们首先应该去读程序所定义的数据结构，在C语言里是struct，而java等面向对象的语言里就是class。在如今模块化的编程时代，我们大部分都有一直面向对象的编程思想，在我看来这是一种优秀的数据组织形式，它将大部分的实体与相应操作全都封装了，对于先整体后局部读源码有许多便利之处。多说无益，我们直接开始lua的源码之旅吧。</p>
<h1 id="lua解释器"><a href="#lua解释器" class="headerlink" title="lua解释器"></a>lua解释器</h1><p>我们先来看看官方程序是如何利用lua虚拟机实现解释器的。</p>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>lua的入口函数长这样</p>
<figure class="highlight c"><figcaption><span>lua.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Smain</span> <span class="title">s</span>;</span></span><br><span class="line">  lua_State *L = lua_open();  <span class="comment">/* create state */</span></span><br><span class="line">  <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    l_message(argv[<span class="number">0</span>], <span class="string">&quot;cannot create state: not enough memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  s.argc = argc;</span><br><span class="line">  s.argv = argv;</span><br><span class="line">  status = lua_cpcall(L, &amp;pmain, &amp;s);</span><br><span class="line">  report(L, status);</span><br><span class="line">  lua_close(L);</span><br><span class="line">  <span class="keyword">return</span> (status || s.status) ? EXIT_FAILURE : EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>int status;</code>声明一个用来存储返回状态的变量，0表示一切正常，都是C的基本内容了。为什么我可以看出来？看最后一句<code>return (status || s.status) ? EXIT_FAILURE : EXIT_SUCCESS;</code>，0也表示false，这是我们发现了另一个结构体<code>struct Smain s;</code>，它的定义在上面几行：</p>
<figure class="highlight c"><figcaption><span>lua.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Smain</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> argc; </span><br><span class="line">  <span class="keyword">char</span> **argv;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>意思也很明显，用来存储参数和返回状态，不知你有没有一个疑问，为什么会有两个status，实际上，这属于调试范畴的东西，我们使用的lua也是一门程序设计语言，当然也有报错的时候，但程序内部会对于lua的错误会存入debug部分，也就是说两个状态分别对应C的运行状态与lua的运行状态，现在少将点，对于Debug的技术，我想另外写一篇文章，所以以后我们跳过debug了哦。<br><code>lua_State *L = lua_open();</code>创建一个虚拟机，我们搞嵌入开发的时候再熟悉不过了。这里我们要注意一点，我们的读的是lua程序的源码(就是指lua.c这个文件)，而不是lua这门语言的源码，就比如Smain这个在lua.c里定义的结构体，我们搞嵌入开发实际上是用不了的。我们阅读源码遵循先整体后局部的思想，目的是减少读我们不需要的源码，提高阅读效率，应该理解哦。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    l_message(argv[<span class="number">0</span>], <span class="string">&quot;cannot create state: not enough memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机创建失败，则报内存不够的错误，值得注意在C里面并没有try和catch进行专业的错误捕捉，一切基本通过返回值是否为NULL或-1来判断。至于创建虚拟机可能出现的问题是lua源码的事，我们等下再说。<code>l_message()</code>是封装在这个文件的报错处理函数，不是太重要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.argc = argc;</span><br><span class="line">s.argv = argv;</span><br></pre></td></tr></table></figure>
<p>将参数传递给Smain，<code>lua_close(L);</code>关闭虚拟机，这些没什么好说的，我们重点关注中间两句话，这应该是核心部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">status = lua_cpcall(L, &amp;pmain, &amp;s);</span><br><span class="line">report(L, status);</span><br></pre></td></tr></table></figure>
<p><code>lua_cpcall()</code>是封装在lua里的函数，参数会作为一个lightuserdata(实际上就是一个void*，可以随意使用，具体转型要自己写，你自己传的东西还不知道吗)放入栈顶，然后调用pmain函数，调用也是使用lua虚拟机来运行，与lua_call一样调用C的函数，不过可以只在pmain依赖栈来运行，所以你做不了什么返回值操作，只有lua系统的返回值。而<code>report(L, status);</code>则是一个用于打印报错信息的函数，属于Debug部分。  </p>
<h2 id="pmain函数"><a href="#pmain函数" class="headerlink" title="pmain函数"></a>pmain函数</h2><p>我们来看pmain的实现：  </p>
<figure class="highlight c"><figcaption><span>lua.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pmain</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Smain</span> *<span class="title">s</span> =</span> (struct Smain *)lua_touserdata(L, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">char</span> **argv = s-&gt;argv;</span><br><span class="line">  <span class="keyword">int</span> script;</span><br><span class="line">  <span class="keyword">int</span> has_i = <span class="number">0</span>, has_v = <span class="number">0</span>, has_e = <span class="number">0</span>;</span><br><span class="line">  globalL = L;</span><br><span class="line">  <span class="keyword">if</span> (argv[<span class="number">0</span>] &amp;&amp; argv[<span class="number">0</span>][<span class="number">0</span>]) progname = argv[<span class="number">0</span>];</span><br><span class="line">  lua_gc(L, LUA_GCSTOP, <span class="number">0</span>);  <span class="comment">/* stop collector during initialization */</span></span><br><span class="line">  luaL_openlibs(L);  <span class="comment">/* open libraries */</span></span><br><span class="line">  lua_gc(L, LUA_GCRESTART, <span class="number">0</span>);</span><br><span class="line">  s-&gt;status = handle_luainit(L);</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;status != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  script = collectargs(argv, &amp;has_i, &amp;has_v, &amp;has_e);</span><br><span class="line">  <span class="keyword">if</span> (script &lt; <span class="number">0</span>) &#123;  <span class="comment">/* invalid args? */</span></span><br><span class="line">    print_usage();</span><br><span class="line">    s-&gt;status = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_v) print_version();</span><br><span class="line">  s-&gt;status = runargs(L, argv, (script &gt; <span class="number">0</span>) ? script : s-&gt;argc);</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;status != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (script)</span><br><span class="line">    s-&gt;status = handle_script(L, argv, script);</span><br><span class="line">  <span class="keyword">if</span> (s-&gt;status != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (has_i)</span><br><span class="line">    dotty(L);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (script == <span class="number">0</span> &amp;&amp; !has_e &amp;&amp; !has_v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lua_stdin_is_tty()) &#123;</span><br><span class="line">      print_version();</span><br><span class="line">      dotty(L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dofile(L, <span class="literal">NULL</span>);  <span class="comment">/* executes stdin as a file */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Smain</span> *<span class="title">s</span> =</span> (struct Smain *)lua_touserdata(L, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> **argv = s-&gt;argv;</span><br></pre></td></tr></table></figure>
<p>从栈顶取出由userdata封装的参数，对于lightuserdata与userdata的区别，其实如果从C语言本身来看都是*void指针，实际上这和垃圾回收有关，我们来看一下lua的数据类型TValue是怎么定义的(lobject.h)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  GCObject *gc;</span><br><span class="line">  <span class="keyword">void</span> *p;</span><br><span class="line">  lua_Number n;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125; Value;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields    Value value; int tt</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>
<p>tt用来标识类别，value存储具体数据。在Value里，我们看到两种指针类型GCObject<em>和void</em>，实际上分别对于了userdata和lightuserdata也就是说，后者不纳入lua的垃圾回收器，需要用户自己进行内存回收，而且lua的API只又lua_pushlightuserdata，也就是说你自己在C里创建的东西自己去管理吧。<br>这里还要讲的是数据在lu虚拟机里的索引，我们看到这里它不像我们一样使用-1来索引栈顶数据，而使用了1，这时我们可能会好奇0是什么，为了理解我们随便取一个索引函数看一下源码(lua_tonumber() in lapi.c)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TValue *<span class="title">index2adr</span> <span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    TValue *o = L-&gt;base + (idx - <span class="number">1</span>);</span><br><span class="line">    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);</span><br><span class="line">    <span class="keyword">if</span> (o &gt;= L-&gt;top) <span class="keyword">return</span> cast(TValue *, luaO_nilobject);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> o;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (idx &gt; LUA_REGISTRYINDEX) &#123;</span><br><span class="line">    api_check(L, idx != <span class="number">0</span> &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);</span><br><span class="line">    <span class="keyword">return</span> L-&gt;top + idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">switch</span> (idx) &#123;  <span class="comment">/* pseudo-indices */</span></span><br><span class="line">    <span class="keyword">case</span> LUA_REGISTRYINDEX: <span class="keyword">return</span> registry(L);</span><br><span class="line">    <span class="keyword">case</span> LUA_ENVIRONINDEX: &#123;</span><br><span class="line">      Closure *func = curr_func(L);</span><br><span class="line">      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);</span><br><span class="line">      <span class="keyword">return</span> &amp;L-&gt;env;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GLOBALSINDEX: <span class="keyword">return</span> gt(L);</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      Closure *func = curr_func(L);</span><br><span class="line">      idx = LUA_GLOBALSINDEX - idx;</span><br><span class="line">      <span class="keyword">return</span> (idx &lt;= func-&gt;c.nupvalues)</span><br><span class="line">                ? &amp;func-&gt;c.upvalue[idx<span class="number">-1</span>]</span><br><span class="line">                : cast(TValue *, luaO_nilobject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LUA_API lua_Number <span class="title">lua_tonumber</span> <span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">  TValue n;</span><br><span class="line">  <span class="keyword">const</span> TValue *o = index2adr(L, idx);</span><br><span class="line">  <span class="keyword">if</span> (tonumber(o, &amp;n))</span><br><span class="line">    <span class="keyword">return</span> nvalue(o);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>index2adr()</code>是最终提供索引结果的函数，并且返回相应的TValue。如果idx&gt;0则返回base+(idx-1)处的值，如果idx&gt;LUA_REGISTRYINDEX则返回top+indx，剩下的我们基本没用，因为在lua.h里我们可以看到<code>#define LUA_REGISTRYINDEX (-10000)</code>，也就是说，0返回top,-1返回top-1,1返回base+1，这里我们涉及了lua虚拟机的两个指针top和base，而且top并非指向最上面的元素，而是指向NULL，还记得我们之前用过的lua_gettop()吗？(lapi.c)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cast_int(i)     cast(int, (i))</span></span><br><span class="line"><span class="function">LUA_API <span class="keyword">int</span> <span class="title">lua_gettop</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cast_int(L-&gt;top - L-&gt;base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们要讲一下base指针了，实际上这存在与函数调用的时候，我们知道lua调用函数的时候都会先将函数入栈，再入参数，实际上调用lua_pcall或lua_call的时候，lua系统会将base指针重新定位为这个函数，所以base+i就会是第i个参数，如果你干过反编译的话，就会发现每一个函数闭包好像都有一个小的虚拟栈，实际上都是lua虚拟机的一部分，base指针以上就是这个小虚拟机，有没有觉得这是一种挺有趣的思想。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> script;</span><br><span class="line"><span class="keyword">int</span> has_i = <span class="number">0</span>, has_v = <span class="number">0</span>, has_e = <span class="number">0</span>;</span><br><span class="line">globalL = L;</span><br><span class="line"><span class="keyword">if</span> (argv[<span class="number">0</span>] &amp;&amp; argv[<span class="number">0</span>][<span class="number">0</span>]) progname = argv[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>前两组变量用来存储lua程序的参数解析结果，lua实际还有好几种用法比如<code>lua -v</code>显示版本信息，<code>lua -i</code>启动交互解释器，等同于<code>lua</code>。这不是我们关注的重点。globalL和progname用来存储程序使用的lua虚拟机和程序名，定义在程序前面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> lua_State *globalL = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *progname = LUA_PROGNAME;</span><br></pre></td></tr></table></figure>
<p>接下来是，向虚拟机导入库函数，涉及一些gc操作，主要为了导入后，让库函数不要在回收的对象里。<br><code>collectargs()</code>用来匹配参数，选项存储到<code>has_i , has_v, has_e</code>里面，返回脚本文件名(非’-‘开头)在参数组里的索引。<br>if{}用来判断是否有脚本参数，否则打印使用信息。如果有<code>has_v</code>则打印版本信息。<code>runargs()</code>针对参数，执行相应操作如<code>-e -l</code>等。<code>if (s-&gt;status != 0) return 0;</code>用来检验运行是否正常，属于”常规操作”了。<br><code>handle_script(L, argv, script);</code>是我们处理lua脚本的主要文件了，后面几句是用来进入交互环境的，核心是<code>dotty(L);</code>函数。</p>
<h2 id="handle-script函数"><a href="#handle-script函数" class="headerlink" title="handle_script函数"></a>handle_script函数</h2><p>我们先往上看前一个：</p>
<figure class="highlight c"><figcaption><span>lua.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_script</span> <span class="params">(lua_State *L, <span class="keyword">char</span> **argv, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fname;</span><br><span class="line">  <span class="keyword">int</span> narg = getargs(L, argv, n);  <span class="comment">/* collect arguments */</span></span><br><span class="line">  lua_setglobal(L, <span class="string">&quot;arg&quot;</span>);</span><br><span class="line">  fname = argv[n];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fname, <span class="string">&quot;-&quot;</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[n<span class="number">-1</span>], <span class="string">&quot;--&quot;</span>) != <span class="number">0</span>) </span><br><span class="line">    fname = <span class="literal">NULL</span>;  <span class="comment">/* stdin */</span></span><br><span class="line">  status = luaL_loadfile(L, fname);</span><br><span class="line">  lua_insert(L, -(narg+<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">    status = docall(L, narg, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    lua_pop(L, narg);      </span><br><span class="line">  <span class="keyword">return</span> report(L, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>int status;const char *fname;</code><br>存储状态和脚本文件名，直接过。<code>getargs(L, argv, n);lua_setglobal(L, &quot;arg&quot;);</code>主要用来将参数放入lua虚拟机的全局变量arg，<code>getargs</code>返回参数的个数。这里指的是对于lua脚本而言的参数，对于lua程序而言就是脚本名后面的参数。官方也已经给出了说明：</p>
<blockquote>
<p>$ lua -la b.lua t1 t2</p>
</blockquote>
<blockquote>
<p>the table is like this:</p>
</blockquote>
<blockquote>
<p>arg = { [-2] = “lua”, [-1] = “-la”,<br>        [0] = “b.lua”,<br>        [1] = “t1”, [2] = “t2” }</p>
</blockquote>
<p>接下来的句子是用来检测的，一般都会通过，但还是以防万一。<code>luaL_loadfile(L, fname);</code>载入脚本，在栈顶产生一个函数闭包来封装脚本。<code>lua_insert(L, -(narg+1));</code>将栈顶函数下移narg+1，这里有点忘说了，在执行<code>getargs(L, argv, n);</code>后，此时栈已经多了narg个参数和一个包含参数的表，执行<code>lua_setglobal(L, &quot;arg&quot;);</code>后栈上实际上还有narg个参数在上面，此时函数与参数在栈上的位置实际反了，所以要执行lua_insert来纠正，其实本身没有必要因为在lua脚本里我们又不能直接调用虚拟机上的参数。<br>后面比较简单了，如果status正常则直接<code>docall()</code>执行代码，否则弹出函数和参数，通过report()报错。<br>我们来看看<code>docall()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">docall</span> <span class="params">(lua_State *L, <span class="keyword">int</span> narg, <span class="keyword">int</span> clear)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">int</span> base = lua_gettop(L) - narg;  <span class="comment">/* function index */</span></span><br><span class="line">  lua_pushcfunction(L, traceback);  <span class="comment">/* push traceback function */</span></span><br><span class="line">  lua_insert(L, base);  <span class="comment">/* put it under chunk and args */</span></span><br><span class="line">  signal(SIGINT, laction);</span><br><span class="line">  status = lua_pcall(L, narg, (clear ? <span class="number">0</span> : LUA_MULTRET), base);</span><br><span class="line">  signal(SIGINT, SIG_DFL);</span><br><span class="line">  lua_remove(L, base);  <span class="comment">/* remove traceback function */</span></span><br><span class="line">  <span class="comment">/* force a complete garbage collection in case of errors */</span></span><br><span class="line">  <span class="keyword">if</span> (status != <span class="number">0</span>) lua_gc(L, LUA_GCCOLLECT, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细一看，它写得还挺专业的。先记录status和base的位置，推入<code>traceback</code>函数并移入底部(base处)，这个主要用于在lua脚本里来进行debug报错，跳过，我以后专门来讲。然后监听中断信号，的确考虑挺多的。lua_pcall()执行函数。然后就是各种恢复操作了——移除中断，移除traceback，进行垃圾回收。看得我自己都忏愧了，自己用惯了那些自带垃圾回收的语言，写C的时候都没考虑过这么多，不过操作系统实际上也会进行管理，不用过于担心就是了。</p>
<h2 id="dotty函数"><a href="#dotty函数" class="headerlink" title="dotty函数"></a>dotty函数</h2><p>这是用来处理交互环境时的函数，代码如下：</p>
<figure class="highlight c"><figcaption><span>lua.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dotty</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *oldprogname = progname;</span><br><span class="line">  progname = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> ((status = loadline(L)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) status = docall(L, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    report(L, status);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span> &amp;&amp; lua_gettop(L) &gt; <span class="number">0</span>) &#123;  <span class="comment">/* any result to print? */</span></span><br><span class="line">      lua_getglobal(L, <span class="string">&quot;print&quot;</span>);</span><br><span class="line">      lua_insert(L, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (lua_pcall(L, lua_gettop(L)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">        l_message(progname, lua_pushfstring(L,</span><br><span class="line">                               <span class="string">&quot;error calling &quot;</span> LUA_QL(<span class="string">&quot;print&quot;</span>) <span class="string">&quot; (%s)&quot;</span>,</span><br><span class="line">                               lua_tostring(L, <span class="number">-1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_settop(L, <span class="number">0</span>);  <span class="comment">/* clear stack */</span></span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  progname = oldprogname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p>前后都是比较常规的操作，重点在while循环里面。首先会执行<code>loadline(L)</code>，这个函数其实挺复杂的，等下我们再说吧，总之最后在栈顶会产生一个无参数的函数，而下面还存储了需要打印信息(后面解释)。然后调用<code>docall()</code>执行这个函数，然后打印需要打印的信息，这是交互环境特有的一个特性，主要用来监听变量信息。比如你之前有一个全局变量a，在交互环境内就可以直接输入a，就可以打印a的值了，其实等同于代码<code>print(a)</code>，但更加方便了。<br>接下来我们看看loadline()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loadline</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  lua_settop(L, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!pushline(L, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* no input */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;  <span class="comment">/* repeat until gets a complete line */</span></span><br><span class="line">    status = luaL_loadbuffer(L, lua_tostring(L, <span class="number">1</span>), lua_strlen(L, <span class="number">1</span>), <span class="string">&quot;=stdin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!incomplete(L, status)) <span class="keyword">break</span>;  <span class="comment">/* cannot try to add lines? */</span></span><br><span class="line">    <span class="keyword">if</span> (!pushline(L, <span class="number">0</span>))  <span class="comment">/* no more input? */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;\n&quot;</span>);  <span class="comment">/* add a new line... */</span></span><br><span class="line">    lua_insert(L, <span class="number">-2</span>);  <span class="comment">/* ...between the two lines */</span></span><br><span class="line">    lua_concat(L, <span class="number">3</span>);  <span class="comment">/* join them */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_saveline(L, <span class="number">1</span>);</span><br><span class="line">  lua_remove(L, <span class="number">1</span>);  <span class="comment">/* remove line */</span></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lua_settop(L, 0);</code>依据base指针移动top指针位置，都是防止出问题的措施，跳过。<code>pushline()</code>用于将用户输入的一行数据压入虚拟机栈，有0和1两个参数，因为C没有bool类型，所以以整数代替，1表示非函数内输入。这里需要讲一下，lua交互环境的运行状态了，它有两种情况，在命令行的表现是以<code>&gt;</code>或<code>&gt;&gt;</code>开头，<code>&gt;</code>开头属于可以直接执行的状态，输入一行执行一行，此时参数为1，<code>&gt;&gt;</code>一般在输入function后进入，此时你基本可以任意输入，直到输入end结尾，当然还有出现内部函数的情况，此时参数为0。感觉把后面的都说了，我们继续看吧。<br>接下来是一个for循环，直到输入一行，这里的一行是个抽象意，处于<code>&gt;</code>状态回车后就是一行，而<code>&gt;&gt;</code>状态需要整个函数闭包输入结束才行。<code>luaL_loadbuffer()</code>载入栈顶的数据，<code>incomplete()</code>根据返回状态，判断是否结束。这就是我之前说的。如果输入的一句话合格的话，就会直接break调，否则开始<code>pushline()</code>处于<code>&gt;&gt;</code>状态的代码，后面部分就是将新读取的字符串拼接了。这里实际上有几个问题没有解决，就是luaL_loadbuffer()对错误返回的结果问题，这个先留到后面，到时候我们会深入分析lua_load函数，最后两句用处不大，直接跳过。这是我们要注意一下，栈顶存在的字符串最后都会被luaL_loadbuffer()掉，也就是说，此函数最后的结果如我们之前所说，是一个函数。</p>
<h1 id="lua编译器"><a href="#lua编译器" class="headerlink" title="lua编译器"></a>lua编译器</h1><p>接下来我们将目光投向lua的编译器，但我么需要注意lua并不能编译为操作系统的可执行文件，而是lua虚拟机的字节码文件。</p>
<h2 id="main函数-1"><a href="#main函数-1" class="headerlink" title="main函数"></a>main函数</h2><figure class="highlight c"><figcaption><span>luac.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> lua_State* L;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Smain</span> <span class="title">s</span>;</span></span><br><span class="line"> <span class="keyword">int</span> i=doargs(argc,argv);</span><br><span class="line"> argc-=i; argv+=i;</span><br><span class="line"> <span class="keyword">if</span> (argc&lt;=<span class="number">0</span>) usage(<span class="string">&quot;no input files given&quot;</span>);</span><br><span class="line"> L=lua_open();</span><br><span class="line"> <span class="keyword">if</span> (L==<span class="literal">NULL</span>) fatal(<span class="string">&quot;not enough memory for state&quot;</span>);</span><br><span class="line"> s.argc=argc;</span><br><span class="line"> s.argv=argv;</span><br><span class="line"> <span class="keyword">if</span> (lua_cpcall(L,pmain,&amp;s)!=<span class="number">0</span>) fatal(lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line"> lua_close(L);</span><br><span class="line"> <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现大部分代码类似于lua解释器。<code>doargs()</code>用来进行参数匹配，同时对于可执行参数就直接执行了，如<code>-v</code>，不过有些信息就直接写入了全局变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGNAME        <span class="meta-string">&quot;luac&quot;</span>          <span class="comment">/* default program name */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT          PROGNAME <span class="meta-string">&quot;.out&quot;</span> <span class="comment">/* default output file */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> listing=<span class="number">0</span>;                   <span class="comment">/* list bytecodes? */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dumping=<span class="number">1</span>;                   <span class="comment">/* dump bytecodes? */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stripping=<span class="number">0</span>;                 <span class="comment">/* strip debug information? */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Output[]=&#123; OUTPUT &#125;;        <span class="comment">/* default output file name */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* output=Output;       <span class="comment">/* actual output file name */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* progname=PROGNAME;   <span class="comment">/* actual program name */</span></span><br></pre></td></tr></table></figure>
<p>返回值是脚本的位置。<code>fatal()</code>类似于之前的<code>report()</code>，用于调试。<code>argc-=i; argv+=i;</code>用来充新定位参数起始位置为脚本位置。流程与lua解释器差不多，我们转向pmain函数。</p>
<h2 id="pmain函数-1"><a href="#pmain函数-1" class="headerlink" title="pmain函数"></a>pmain函数</h2><figure class="highlight c"><figcaption><span>luac.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pmain</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Smain</span>* <span class="title">s</span> =</span> (struct Smain*)lua_touserdata(L, <span class="number">1</span>);</span><br><span class="line"> <span class="keyword">int</span> argc=s-&gt;argc;</span><br><span class="line"> <span class="keyword">char</span>** argv=s-&gt;argv;</span><br><span class="line"> <span class="keyword">const</span> Proto* f;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">if</span> (!lua_checkstack(L,argc)) fatal(<span class="string">&quot;too many input files&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* filename=IS(<span class="string">&quot;-&quot;</span>) ? <span class="literal">NULL</span> : argv[i];</span><br><span class="line">  <span class="keyword">if</span> (luaL_loadfile(L,filename)!=<span class="number">0</span>) fatal(lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> f=combine(L,argc);</span><br><span class="line"> <span class="keyword">if</span> (listing) luaU_print(f,listing&gt;<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span> (dumping)</span><br><span class="line"> &#123;</span><br><span class="line">  FILE* D= (output==<span class="literal">NULL</span>) ? <span class="built_in">stdout</span> : fopen(output,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (D==<span class="literal">NULL</span>) cannot(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  luaU_dump(L,f,writer,D,stripping);</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">if</span> (ferror(D)) cannot(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fclose(D)) cannot(<span class="string">&quot;close&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前三句好说，下一句我们见到了一个新的数据类型<code>Proto</code>，这个我们或许要深入了解一下了。不过在此之前我们先读完全部内容吧，其实影响不会太大。<code>lua_checkstack()</code>见多了，用来保证还能继续往栈里写数据。接下来对所有合格参数都执行一遍<code>luaL_loadfile()</code>，可见luac还可以批量编译，而且还会打包为一个文件，此时lua虚拟机栈上已经有相应数量的函数了。<code>combine()</code>有点复杂，还涉及字节码，我们先放一放，总之它将我们栈上的函数打包为了一个Proto。<code>listing</code>用于打印字节码信息，对应<code>-l</code>参数，<code>dumping</code>默认开启，用于输出字节码文件，可以使用<code>-p</code>取消。里面一个重要的函数是<code>luaU_dump(L,f,writer,D,stripping);</code>，它将proto文件f打包到输出流writer上去，stripping表示是否有调试信息，默认不包含。</p>
<h2 id="Proto结构体"><a href="#Proto结构体" class="headerlink" title="Proto结构体"></a>Proto结构体</h2><p>想必你已经听过许多遍，lua执行过程是先将lua编译为字节码，再在虚拟机上执行。实际上，我们之前学过的用CAPI去操作虚拟机，实际上，这些操作有一个对应的集合，就是字节码。在执行lua_load后，虚拟机会将脚本封装为一个函数，这个函数即包含了脚本编译后的字节码，我们留到以后说，而Proto则是函数的超集，或者说栈上TValue的最后结果是Proto，实际上这里有比较复杂的指向关系，我们先跳过，我们去看一看Proto吧：</p>
<figure class="highlight c"><figcaption><span>luac.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Function Prototypes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  TValue *k;  <span class="comment">/* constants used by the function */</span></span><br><span class="line">  Instruction *code;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> **<span class="title">p</span>;</span>  <span class="comment">/* functions defined inside the function */</span></span><br><span class="line">  <span class="keyword">int</span> *lineinfo;  <span class="comment">/* map from opcodes to source lines */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LocVar</span> *<span class="title">locvars</span>;</span>  <span class="comment">/* information about local variables */</span></span><br><span class="line">  TString **upvalues;  <span class="comment">/* upvalue names */</span></span><br><span class="line">  TString  *source;</span><br><span class="line">  <span class="keyword">int</span> sizeupvalues;</span><br><span class="line">  <span class="keyword">int</span> sizek;  <span class="comment">/* size of `k&#x27; */</span></span><br><span class="line">  <span class="keyword">int</span> sizecode;</span><br><span class="line">  <span class="keyword">int</span> sizelineinfo;</span><br><span class="line">  <span class="keyword">int</span> sizep;  <span class="comment">/* size of `p&#x27; */</span></span><br><span class="line">  <span class="keyword">int</span> sizelocvars;</span><br><span class="line">  <span class="keyword">int</span> linedefined;</span><br><span class="line">  <span class="keyword">int</span> lastlinedefined;</span><br><span class="line">  GCObject *gclist;</span><br><span class="line">  lu_byte nups;  <span class="comment">/* number of upvalues */</span></span><br><span class="line">  lu_byte numparams;</span><br><span class="line">  lu_byte is_vararg;</span><br><span class="line">  lu_byte maxstacksize;</span><br><span class="line">&#125; Proto;</span><br></pre></td></tr></table></figure>
<p><code>CommonHeader;</code>和<code>gclist</code>与垃圾回收相关，我们下次专门讲。<code>*k</code>存储函数里的常量，<code>*code</code>存储函数内的指令，<code>**p</code>是函数内的函数数组，lua函数套函数应该不少见。<code>*lineinfo</code>存储源码行号，<code>*source</code>存储源码，主要用于debug。<code>*locvars</code>存储本地变量，就是有local申明的变量，注意这里存储的只是相关信息，如名称，它的值实际存在lua虚拟机里，等我们熟悉字节码操作后，就能更深理解存储机制了。<code>*upvalues</code>存储上下文变量，主要存在于多重函数嵌套里面。一个函数的upvalue指的是，它之前级函数的local函数，这里已经有许多涉及字节码的理念了，先放放。<code>int sizeupvalues;int sizek;/* size of k */int sizecode;int sizelineinfo;int sizep;/* size of p */int sizelocvars;</code>存储各个变量的大小，注意不是个数，<code>linedefined</code>和<code>lastlinedefined;</code>是函数的始末行号，用于调试。后面分别是upval个数，参数个数，是否有可变参数，栈最高用到多少。实际上，把Proto当成一个函数也没有问题。</p>
<h2 id="luaU-dump函数"><a href="#luaU-dump函数" class="headerlink" title="luaU_dump函数"></a>luaU_dump函数</h2><p><code>int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)</code>这个和lua_load类似，具体内容等我讲luac反编译再说。data提供输出流，w提供输出的具体函数，f就是需要打包的内容，strip表示是否打包调试信息。</p>
<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>为了更加深入了解lua的函数和，lua代码究竟如何在虚拟机上运行的，我们就必需深入了解一下字节码了。</p>
<h2 id="字节码大全"><a href="#字节码大全" class="headerlink" title="字节码大全"></a>字节码大全</h2><p>虽然没有必要但还是讲一下，lua的所有字节码和它们是如何影响lua虚拟机的运行的。操作码有两部分组成，操作和操作数。对于操作数有三种情况，一是虚拟栈索引(记为v)，另一种是函数里里的常数表索引(记为c)，最后就是布尔数(只要0和1，记为b)，在lua里所有立即数据和名称都会计入函数的常量表，如<code>local a = 3</code>里的a和3。</p>
<h3 id="关于索引的问题"><a href="#关于索引的问题" class="headerlink" title="关于索引的问题"></a>关于索引的问题</h3><p>每一个函数，都会有base指针的移动，在字节码里是从0开始索引，不过还有一点，就是如果有参数的话，就会占用相应参数个位置。</p>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><p>以后我在后面标一个符号，表示索引的种类。<code>OP_MOVE(A v, B v) A=B</code>，<code>OP_LOADK(A v, B c) A=B</code>，<code>OP_LOADBOOL(A v, B b, C b) A=B,if(C) pc++</code>，这个指令看似复杂，但实际就是进行布尔赋值或运算的时候会用到，pc就是程序计数器，pc++即跳过下一条指令。自己用对lua的and or语句编译一下，就能发现其中的奥秘。<code>OP_LOADNIL(A v, B nil) A=nil</code>，这个比较特别，B基本都是0。</p>
<h3 id="表相关"><a href="#表相关" class="headerlink" title="表相关"></a>表相关</h3><p>接下来会有几个需要的表，upval表和global表。<code>OP_GETUPVAL(A v, B c) A=upval[B]</code>，<code>OP_SETUPVAL(A v, B c) upval[B] = A</code>，<code>OP_GETGLOBAL(A v, B c) A=global[B]</code>，<code>OP_SETGLOBAL(A v, B c) global[B]=A</code>，<code>OP_GETTABLE(A v, B v, C c) A=B[C]</code>，<code>OP_SETTABLE(A v, B c, C v) A[B]=C</code>，<br><code>OP_NEWTABLE(A v, B c, C c)</code>创建一个表，array大小为B，hash大小为C，后面一般紧跟相应数量的OP_LOAD*和OP_SETTABLE来填数据，最后<code>OP_SETLIST(A v, B c, C c)</code>,B和C同上，有时opcode是联合使用的，取决于编译器load_*的内部实现。<code>OP_SELF(A v, B v, C c)</code>，在lua传输self表时特有的一个函数，注意的是这个表在表里是独立存在的，self的变量与表里的变量是不同的，self类似于表私有的变量。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p><code>OP_ADD(A v, B v, C v) A=B+C</code>，<code>OP_SUB(A v, B v, C v) A=B-C</code>，<code>OP_MUL(A v, B v, C v) A=B*C</code>，<code>OP_DIV(A v, B v, C v) A=B/C</code>，<code>OP_MOD(A v, B v, C v) A=B%C</code>，<code>OP_POW(A v, B v, C v) A=B^C</code>，<code>OP_UNM(A v, B v) A= -B</code>，<code>OP_NOT(A v, B v) A= not B</code>，<code>OP_LEN(A v, B v) A=#B</code>，<code>OP_CONCAT(A v, B v, C v) A= B..C</code>，我们发现所有的运算都在栈上运算，就如我之前所说，在lua里所有的变量值要么存储在栈上，要么在全局表里面。而函数闭包，只存储变量的名称，或立即数据，因为它是需要静态存储到文件里的，lua其实还有优化编译，如对于<code>a = 2+5</code>，lua会直接存储a和7而不是a,2和5。</p>
<h3 id="结构控制"><a href="#结构控制" class="headerlink" title="结构控制"></a>结构控制</h3><p><code>OP_JMP(0, B) pc+=B</code>，这里还要讲一下pc指向的是将要执行的指令，一般指向下一条，在这里B是具体整数，一般是正数。<code>OP_EQ(A b, B v, C v) if((B==C)~=A)then pc++</code>，这里实际通过A分开了==和!=，下面同理，<code>OP_LT(A b, B v, C v) if((B&lt;C)~=A)then pc++</code>，<code>OP_LE(A b, B v, C v) if((B&lt;=C)~=A)then pc++</code>，有关lua代码如何转化为字节码，有些什么巧妙之处，我还在反编译那里讲。<code>OP_TEST(A v, B b) if not(A==B)then pc++</code>，<code>OP_TESTSET(A v, B v, C b) if(B==C)then A=B else pc++</code>，这个主要用在复杂的逻辑表达式里。<code>OP_FORLOOP(A v, B) A+=v(A+2)</code>用于for循环，一般会在栈上产生三个值，一个是我们常用的索引，最后一个步长，v(A+2)表示相对A位置加2处的值，B用于指示跳转，一般是负数表示回退。<code>OP_FORPREP(A v, B) A-=v(A+2),pc+=B</code>与<code>OP_TFORLOOP(A v, C) v(A+3),…,v(A+2+C)=A(v(A+1),v(A+2))</code>一般配合使用来遍历表，C表示返回值个数，一般为3，用过pairs和ipairs吧。对于while和repeat，只要jmp和比较其实就能实现了。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>OP_CALL(A v, B, C) v(A),…v(A+C-2)=A(v(A+1),…v(A+B-1))</code>,B-1和C-1分别是参数和返回值个数，与lua_call使用差不多，但有一个减一操作，即2表示一个参数，有些用处，但现在就当是规定吧。<code>OP_TAILCALL(A v, B, C) return A(v(A+1),…v(A+B-1))</code>类似上一个，用于函数的快速返回。<code>OP_RETURN(A v, B) return v(A+1),…v(A+B-1)</code>标准的函数返回方式。<code>OP_CLOSE(A v)</code> 清除栈上&gt;=A的所有值，<code>OP_CLOSURE(A v,B)</code>取出函数内的闭包到栈上，B是索引，还记得Proto内的Proto，闭包就存在里面。<code>OP_VARARG(A v, B) v(A),…v(A+B-1)=…</code>用来取出B个函数的可变参数到栈上。</p>
<h2 id="字节码总结"><a href="#字节码总结" class="headerlink" title="字节码总结"></a>字节码总结</h2><p>至此，我们浏览了所有的字节码，只是为了有个大概的印象，实际还是得结合具体的编译结果来看，一般成块出现的，我们可以使用指令<code>luac -l [字节码文件]</code>来查看。对于字节码，我们需要记住，所有要操作的数据都要先入栈，返回值也存在栈上，其实这也就方便了我们通过CAPI来实现C语言与lua的数据交互，当然还可以通过全局变量表。同时我们也看到了，函数Proto并没有存具体的数据，除了那些即时产生的量，而是存储了变量名等变量的特征，我们要清楚，函数是静态存储动态执行的，所以变量的具体值不在函数里也是理所应当的。</p>
<h1 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h1><p>前面讲了函数的一个重要组成部分<code>Instruction *code</code>即字节码，是时候该从新正视一下函数了，函数属于TValue里Value的GCObject。我们来看一下这条定义链。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lobject.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  GCObject *gc;</span><br><span class="line">  <span class="keyword">void</span> *p;</span><br><span class="line">  lua_Number n;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125; Value;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Closures</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClosureHeader \</span></span><br><span class="line"><span class="meta">        CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; \</span></span><br><span class="line"><span class="meta">        struct Table *env</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CClosure</span> &#123;</span></span><br><span class="line">  ClosureHeader;</span><br><span class="line">  lua_CFunction f;</span><br><span class="line">  TValue upvalue[<span class="number">1</span>];</span><br><span class="line">&#125; CClosure;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span> &#123;</span></span><br><span class="line">  ClosureHeader;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> *<span class="title">p</span>;</span></span><br><span class="line">  UpVal *upvals[<span class="number">1</span>];</span><br><span class="line">&#125; LClosure;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Closure</span> &#123;</span></span><br><span class="line">  CClosure c;</span><br><span class="line">  LClosure l;</span><br><span class="line">&#125; Closure;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lstate.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all collectable objects</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  GCheader gch;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">TString</span> <span class="title">ts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Udata</span> <span class="title">u</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Closure</span> <span class="title">cl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">h</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> <span class="title">uv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> <span class="title">th</span>;</span>  <span class="comment">/* thread */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  
<p>我们看到有Closure和Proto两个，我们使用lua_call一般针对的是Closure，而Proto出现在这里是因为它也是要回收的对象。实际上对于函数有两种，一个是C闭包，还有一个是lua闭包，它们都可以作为函数供lua_call来调用，所以闭包了一个Closure作为统一对象。Proto则是LClosure(lua闭包函数)的主要部分。<code>lua_CFunction f;</code>的申明在lua.h里，格式如下<code>typedef int (*lua_CFunction) (lua_State *L);</code>。垃圾回收还是老话，以后再讲。</p>
<h2 id="combine函数"><a href="#combine函数" class="headerlink" title="combine函数"></a>combine函数</h2><p>在前面，我们提到了一个<code>combine(L, int)</code>函数，用来将栈上的函数返回为为一个Proto，我们看看它：</p>
<figure class="highlight c"><figcaption><span>luac.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Proto* <span class="title">combine</span><span class="params">(lua_State* L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> toproto(L,<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">int</span> i,pc;</span><br><span class="line">  Proto* f=luaF_newproto(L);</span><br><span class="line">  setptvalue2s(L,L-&gt;top,f); incr_top(L);</span><br><span class="line">  f-&gt;source=luaS_newliteral(L,<span class="string">&quot;=(&quot;</span> PROGNAME <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  f-&gt;maxstacksize=<span class="number">1</span>;</span><br><span class="line">  pc=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">  f-&gt;code=luaM_newvector(L,pc,Instruction);</span><br><span class="line">  f-&gt;sizecode=pc;</span><br><span class="line">  f-&gt;p=luaM_newvector(L,n,Proto*);</span><br><span class="line">  f-&gt;sizep=n;</span><br><span class="line">  pc=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   f-&gt;p[i]=toproto(L,i-n<span class="number">-1</span>);</span><br><span class="line">   f-&gt;code[pc++]=CREATE_ABx(OP_CLOSURE,<span class="number">0</span>,i);</span><br><span class="line">   f-&gt;code[pc++]=CREATE_ABC(OP_CALL,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;code[pc++]=CREATE_ABC(OP_RETURN,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个函数，则直接返回<code>toproto(L,-1);</code>，这个的定义链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//luac.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> toproto(L,i) (clvalue(L-&gt;top+(i))-&gt;l.p)</span></span><br><span class="line"><span class="comment">//lua.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> check_exp(c,e)          (e)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ttisfunction(o) (ttype(o) == LUA_TFUNCTION)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clvalue(o) check_exp(ttisfunction(o), &amp;(o)-&gt;value.gc-&gt;cl)</span></span><br></pre></td></tr></table></figure>
<p>转化一下就是<code>toproto(L,-1)</code> := <code>&amp;(L-&gt;top-1)-&gt;value.gc-&gt;cl-&gt;l.p</code>，取出TValue的value(Value)的gc(GCObject)的cl(Closure)的l(LClosure)的p(Proto)，的确是一个复杂的过程，但这也是为了统一处理。<br>对于函数大于1的情况也可以看一看，其实就是将每个函数执行的代码，再封装到一个Proto里面。<code>Proto* f=luaF_newproto(L);</code>创建一个Proto。<code>setptvalue2s(L,L-&gt;top,f); incr_top(L);</code>虽然复杂，但其实就是将Proto封装为TValue并放入栈顶的操作。<code>f-&gt;source=luaS_newliteral(L,&quot;=(&quot; PROGNAME &quot;)&quot;);</code>和<code>f-&gt;maxstacksize=1;</code>用于给Proto补充信息，栈只要1格内存来存Closure就足够了。<code>pc=2*n+1;</code>标识需要的字节码个数，一个文件两个，最后加一个return，<code>f-&gt;code=luaM_newvector(L,pc,Instruction);</code>创建Instruction的数组，<code>f-&gt;sizecode=pc;</code>最后记录到Proto里面。<code>f-&gt;p=luaM_newvector(L,n,Proto*);</code>创建存储每个文件Proto的数组，<code>f-&gt;sizep=n;</code>记录子Proto的个数(Proto可以包含数个子Proto)，<code>pc=0;</code>计数器归位，准备记录字节码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   f-&gt;p[i]=toproto(L,i-n<span class="number">-1</span>);</span><br><span class="line">   f-&gt;code[pc++]=CREATE_ABx(OP_CLOSURE,<span class="number">0</span>,i);</span><br><span class="line">   f-&gt;code[pc++]=CREATE_ABC(OP_CALL,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;code[pc++]=CREATE_ABC(OP_RETURN,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br></pre></td></tr></table></figure>
<p>记录字节码，并将构造的Proto返回。我们可以看到，所谓编译多个文件就是将每个文件都执行一遍。</p>
<h2 id="lua-call函数"><a href="#lua-call函数" class="headerlink" title="lua_call函数"></a>lua_call函数</h2><p>接下来就是要讲讲，我们最重要的执行函数了，也是我们虚拟机运行的核心，对于每一个Proto里面的字节码，执行的主体就是我们的lua_call函数了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="keyword">void</span> <span class="title">lua_call</span> <span class="params">(lua_State *L, <span class="keyword">int</span> nargs, <span class="keyword">int</span> nresults)</span> </span>&#123;</span><br><span class="line">  StkId func;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  api_checknelems(L, nargs+<span class="number">1</span>);</span><br><span class="line">  checkresults(L, nargs, nresults);</span><br><span class="line">  func = L-&gt;top - (nargs+<span class="number">1</span>);</span><br><span class="line">  luaD_call(L, func, nresults);</span><br><span class="line">  adjustresults(L, nresults);</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lua_lock(L);</code>和<code>lua_unlock(L);</code>顾名思义就是用来锁住L，防止操作还没结束就被其它线程改变，但其实在lua里并没有实现此方法，而是定义宏来提供接口，只把lua当一次性脚本的话，不用过于关注。其实如果遇到如<code>api_checknelems</code>，<code>checkresults</code>和<code>adjustresults</code>之类的函数，都可以不用在意，与<code>lua_lock()</code>类似，不改源码的话，基本没什么用。<code>func = L-&gt;top - (nargs+1);</code>把函数取出来，<code>luaD_call(L, func, nresults);</code>才是真正来执行的函数。 </p>
<figure class="highlight c"><figcaption><span>ldo.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaD_call</span> <span class="params">(lua_State *L, StkId func, <span class="keyword">int</span> nResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (++L-&gt;nCcalls &gt;= LUAI_MAXCCALLS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;nCcalls == LUAI_MAXCCALLS)</span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;C stack overflow&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L-&gt;nCcalls &gt;= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS&gt;&gt;<span class="number">3</span>)))</span><br><span class="line">      luaD_throw(L, LUA_ERRERR);  <span class="comment">/* error while handing stack error */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (luaD_precall(L, func, nResults) == PCRLUA)  <span class="comment">/* is a Lua function? */</span></span><br><span class="line">    luaV_execute(L, <span class="number">1</span>);  <span class="comment">/* call it */</span></span><br><span class="line">  L-&gt;nCcalls--;</span><br><span class="line">  luaC_checkGC(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p><code>if (++L-&gt;nCcalls &gt;= LUAI_MAXCCALLS) &#123;</code>主要用于检测当前嵌套函数调用个数有没有超标，少用递归的话基本不会出问题。<code>luaD_precall(L, func, nResults)</code>预调用，如果func是C闭包的话就直接执行并返回PCRC，如果是lua闭包就做好运行准备，比如修改虚拟机的CallInfo，调整base指针之类的，这些是编程细节，不是我们学习的重点，最后会返回PCRLUA，然后接着执行<code>luaV_execute(L, 1)</code>，这个函数是执行字节码的真正函数，实现的话就是一个个去比对然后执行，没什么看头。<code>luaD_precall</code>其实还会返回一个与协程相关的PCRYIELD。<code>L-&gt;nCcalls--;</code>函数嵌套减一，<code>luaC_checkGC(L);</code>垃圾回收操作。<br>至于<code>lua_pcall</code>它最终也是通过<code>luaD_call</code>实现调用，只不过增加了保护措施，防止程序中断，而<code>lua_cpcall</code>则与<code>lua_pcall</code>有类似的实现方式，最终仍是回到<code>luaD_call</code>，就不过多赘述了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>至此lua源码的大致框架和核心部分已经叙述完了，但其实还没有结束，比如Debug，GC机制，协程的实现等都没有讲到。任何源码都是庞大的，其实我们没必要面面俱到，而应先了解其基本框架，再去了解我们想知道的部分就足够了。不要忘了，我们读源码不是要折磨自己，而是想学习优秀的范式。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lua/">lua</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">逯晓零</div><div class="author-info__description">我喜欢简洁，仅此而已。</div></div><div class="card-info-data site-data is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lua%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">lua解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pmain%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">pmain函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handle-script%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">handle_script函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dotty%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">dotty函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lua%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">lua编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0-1"><span class="toc-number">3.1.</span> <span class="toc-text">main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pmain%E5%87%BD%E6%95%B0-1"><span class="toc-number">3.2.</span> <span class="toc-text">pmain函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proto%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.3.</span> <span class="toc-text">Proto结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#luaU-dump%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">luaU_dump函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%A4%A7%E5%85%A8"><span class="toc-number">4.1.</span> <span class="toc-text">字节码大全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.1.</span> <span class="toc-text">关于索引的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.2.</span> <span class="toc-text">赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">4.1.3.</span> <span class="toc-text">表相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.4.</span> <span class="toc-text">运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.5.</span> <span class="toc-text">结构控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.6.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.</span> <span class="toc-text">字节码总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="toc-number">5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#combine%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">combine函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lua-call%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">lua_call函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">6.</span> <span class="toc-text">后记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2023-10-01-%E6%9D%82%E8%B0%88%EF%BC%9A2023-10-01/" title="杂谈：2023.10.01">杂谈：2023.10.01</a><time datetime="2023-10-01T09:15:46.000Z" title="发表于 2023-10-01 17:15:46">2023-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2023-09-03-%E6%88%91%E8%BF%98%E6%83%B3%E5%81%9A%E7%9A%84%E4%BA%8B/" title="我还想做的事">我还想做的事</a><time datetime="2023-09-02T23:41:56.000Z" title="发表于 2023-09-03 07:41:56">2023-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/archives/2023-07-27-%E9%AD%94%E7%BE%A4%E6%9C%88%E5%85%89/" title="魔群月光">魔群月光</a><time datetime="2023-07-27T07:34:21.000Z" title="发表于 2023-07-27 15:34:21">2023-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 逯晓零</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>